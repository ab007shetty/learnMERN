const e=[{id:1,question:"What is the difference between let, const, and var in JavaScript?",answer:["Prefer const by default since it prevents accidental reassignments.","Use let only when a variable’s value truly needs to change like reassignments.","Avoid var since it is function-scoped, hoisted with undefined, so prone to bugs.","Always declare variables at the top of their block to avoid TDZ."],example:["      | Scope          | Hoisting          | Reassign    | Redeclare","------|----------------|-------------------|-------------|------------","var   | Function scope | Yes (undefined)   | Allowed     | Allowed","let   | Block scope    | Yes (TDZ applies) | Allowed     | Not allowed","const | Block scope    | Yes (TDZ applies) | Not allowed | Not allowed"],keyterms:["Scope = area where variable is accessible (function or block)","Hoisting = variables moved to top of scope before execution","TDZ (Temporal Dead Zone) = period after hoisting but before initialization; accessing variable throws error"]},{id:2,question:"What are primitive and non-primitive data types in JavaScript?",answer:["Primitive types are immutable and hold single values. Examples: string, number, boolean, null, undefined, symbol, bigint.","Non-primitive types (reference types) store collections or objects, and are mutable. Examples: object, array, function.","Key Differences:"],example:["Feature           | Primitive        | Non-Primitive","------------------|----------------- |--------------------------","Stored as         | Value            | Reference (in memory)","Mutable           | No               | Yes","Compared by       | Value            | Reference"],keyterms:["In React: Primitives are used in state; non-primitives (like objects/arrays) require careful handling to avoid unwanted re-renders."]},{id:3,question:"What is Recursion and when should you use it?",answer:["A function calling itself to solve smaller subproblems.","Useful for tree/graph traversals, divide-and-conquer.","Tail-call optimization isn’t guaranteed in most JS engines."],example:["function fact(n) {","  if (n <= 1) {","    return 1;","  } else {","    return n * fact(n - 1);","  }","}","console.log(fact(5)); // 120"],keyterms:["Recursion = self-calling function","TCO (Tail Call Optimization) = not reliable in JS"]},{id:4,question:"What are template literals in JavaScript?",answer:["Template literals are strings enclosed by backticks (`) that allow embedded expressions and multi-line strings.","They use ${} for interpolation, making it easy to insert variables or expressions directly in a string."],example:["const name = 'John';","console.log(`Hello, ${name}!`); // Hello, John!"],keyterms:["Template literal = string with backticks (`) supporting expressions and multi-line text","Interpolation = inserting values using ${expression}"]},{id:5,question:"What is the difference between spread and rest operators in JavaScript?",answer:["Spread operator (...) expands an iterable (like array or object) into individual elements.","Rest operator (...) collects multiple elements into an array, often used in function parameters."],example:["// Spread Operator","const arr = [1, 2];","const newArr = [...arr, 3]; // [1, 2, 3]"," ","// Rest Operator","function sum(...args) {","  return args.reduce((a, b) => a + b, 0);","}"],keyterms:["Both use ... but differ by context: spread expands, rest collects. Used heavily in React for props and state management."]},{id:6,question:"What is the difference between Parameters and Arguments?",answer:["Parameters are placeholders in the function definition.","Arguments are actual values passed during the call.","Arity = number of declared parameters."],example:["function add(a, b) {","  return a + b; // a, b = parameters","}"," ","add(4, 5); // 4, 5 = arguments"],keyterms:["Parameter = declared variable","Argument = runtime value"]},{id:7,question:"What are default parameters and rest parameters?",answer:["Default parameters give fallback values when args are missing.","To trigger a default param, you must pass `undefined` explicitly.","Rest parameters collect remaining args into an array.","Use rest instead of `arguments` for clarity."],example:["(function (name = 'ani', b) {","  console.log(name + b);","})(undefined, ' shetty'); // ani shetty"," ","function greet(name = 'Guest') {","  return 'Hi ' + name;","}"," ","function sum(...nums) {","  return nums.reduce((a, b) => a + b, 0);","}"],keyterms:["Default params = fallback","Rest params = variable arity","undefined = triggers default param"]},{id:8,question:"What is the difference between deep copy and shallow copy in JavaScript?",answer:["Shallow copy copies only the first level of an object/array; nested objects still reference the original.","Deep copy copies all nested levels, creating a fully independent clone."],example:["let obj= [1,2,[3,4]]"," ","const copy = {...obj}; // shallow copy"," ","const deepCopy = JSON.parse(JSON.stringify(obj));"," ","console.log(copy)","console.log(deepCopy)"],keyterms:["Shallow copy = top-level copy, nested references shared.","Deep copy = fully independent clone of all nested data. In React, shallow copies are often used for state updates, but deep copies are needed when nested objects change."]},{id:9,question:"What is hoisting and how do var, let, and const behave differently in JavaScript?",answer:["Hoisting is JavaScript’s behavior of moving variable declarations to the top of their scope.","var is hoisted and initialized as undefined.","let and const are also hoisted, but not initialized. They stay in the Temporal Dead Zone (TDZ) until their declaration is reached.","Accessing let or const before declaration causes a ReferenceError."],example:["      | Hoisted? | Initialized? | TDZ Exists? | Access Before Declaration","------|----------|--------------|-------------|---------------------------","var   | Yes      | Yes (undef)  | No          | Allowed (undefined)","let   | Yes      | No           | Yes         | Error in TDZ","const | Yes      | No           | Yes         | TDZ + Must initialize "]},{id:10,question:"What is the Temporal Dead Zone (TDZ) in JavaScript?",answer:["The Temporal Dead Zone is the period between entering a scope and the point where a let or const variable is declared.","It starts when the execution context is created (hoisting happens) and ends when the execution phase reaches the actual declaration line where the variable is initialized."],example:["console.log(a); // ReferenceError"," ","let a = 5;"],keyterms:["TDZ = period between a variable’s hoisting and its initialization.","Prevents access to variables before they're defined","Applies only to let and const, not var. TDZ helps avoid bugs by enforcing proper variable declaration order."]},{id:11,question:"Why are functions called first-class citizens in JavaScript?",answer:["Functions can be assigned to variables.","Functions can be passed as arguments.","Functions can be returned from other functions.","Functions can be stored in objects or arrays."],example:["// assign to variable","const greet = function() { return 'Hello'; };"," ","// pass as argument","function run(fn) { console.log(fn()); }","run(greet); // 'Hello'"," ","// return a function","function outer() { return () => 'Inner'; }","const inner = outer();","console.log(inner()); // 'Inner'"],keyterms:["First-class citizens = treated like values","Functions = assign, pass, return, store"]},{id:12,question:"What is a Function Statement (Declaration) and how does hoisting work?",answer:["A named function defined with the function keyword at top level or inside scopes.","Function declarations are hoisted with their definitions.","You can call them before their appearance in code."],example:["foo();               // This works"," ","function foo() {","  console.log('Hi');","}"],keyterms:["Function declaration = hoisted","Hoisting = definition available earlier"]},{id:13,question:"What is a Function Expression and how is it hoisted?",answer:["A function assigned to a variable/constant.","Only the variable is hoisted (initialized later).","Calling before assignment causes error."],example:["bar(); // TypeError/undefined at call time"," ","var bar = function() {","  console.log('Hi');","};"],keyterms:["Function expression = not fully hoisted","Declaration vs expression hoisting"]},{id:14,question:"What is an Anonymous Function and where is it used?",answer:["A function without a name.","Common in callbacks and IIFEs.","Useful when the function is not reused."],example:["setTimeout(function() {","  console.log('Timer');","}, 500);"],keyterms:["Anonymous = no name","Used as inline callback"]},{id:15,question:"What is an IIFE (Immediately Invoked Function Expression) and how is it different from function currying?",answer:["IIFE is a function that runs immediately after being defined.","It uses ()() syntax → one pair for wrapping, one pair for execution.","Function currying is when a function returns another function and parameters are passed step by step.","Syntax looks similar, but currying delays execution until further calls."],example:["// Example 1: IIFE"," ","(function() {","  console.log('I run immediately!');","})();"," ","// Example 2: Currying"," ","function multiply(a) {","  return function(b) {","    return a * b;","  }","}","console.log(multiply(4)(5)); // 20"],keyterms:["IIFE = Function that executes immediately after creation","Currying = Breaking a function with multiple params into nested functions","()() = Syntax used for both, but purpose differs"]},{id:16,question:"What is Function Currying?",answer:["Transforming a function of n args into a chain of unary functions.","Uses closures to remember earlier arguments.","Useful for partial application and composition."],example:["const add = a => b => a + b;","add(2)(3); // 5"],keyterms:["Currying = f(a,b)->f(a)(b)","Partial application"]},{id:17,question:"What is infinite currying in JavaScript?",answer:["Infinite currying is a function technique where a function keeps returning another function, allowing repeated calls with new arguments.","It usually ends when a condition is met, such as receiving no arguments, at which point it returns the final result."],example:["function add(a) {","  return function(b) {","    if (b !== undefined) return add(a + b);","    return a;","  };","}"," ","console.log(add(1)(2)(3)()); // 6"],keyterms:["Currying = breaking a function with multiple args into a chain of single-arg functions","Infinite currying = currying without a fixed number of arguments, ends with a stop condition"]},{id:18,question:"What is a Named Function Expression and why use it?",answer:["A function expression with an internal name.","Improves stack traces and allows self-recursion.","Name is not available in the outer scope."],example:["const a = function xyz(n){","  if(n<=1) return 1;","  return n*xyz(n-1);","};"," ","a(3); // ok, xyz is not global"],keyterms:["Named expression = inner name only","Better debugging, recursion"]},{id:19,question:"What are First-Class and Higher-Order Functions in JavaScript?",answer:["First-class functions: Functions are treated like variables. They can be assigned, passed as arguments, or returned.","Higher-order functions (HOF): A function that takes one or more functions as arguments (callbacks), or returns a function.","The function passed as an argument is called a callback, and the function receiving it is called the higher-order function."],example:["const radius = [3, 1, 2, 4];"," ","const area = function (r) {","  return Math.PI * r * r;","};"," ","const calculate = function (radiusArr, logic) {","  const output = [];","  for (let i = 0; i < radiusArr.length; i++) {","    output.push(logic(radiusArr[i]));","  }","  return output;","};"," ","console.log(calculate(radius, area)); // [28.27, 3.14, 12.56, 50.27]"],keyterms:["First-class = functions as values (assign, pass, return)","Higher-order = takes/returns functions","Callback = function passed to HOF","DRY principle = Don't Repeat Yourself (reuse logic)"]},{id:20,question:"What is a Callback Function in JavaScript and its top use cases?",answer:["A callback is a function passed as an argument to another function.","It executes later, typically after an operation completes.","Common use cases: timers (setTimeout), event listeners, network requests, and sequencing async tasks.","Callbacks enable async programming and support event-driven designs in JavaScript."],example:["document.getElementById('btn').addEventListener('click', () => {","  btn.innerText = 'clicked';","  console.log('Btn clicked');"," ","  setTimeout(() => {","    btn.innerText = 'Click Me';","  }, 1000);","});"],keyterms:["Callback = function passed to another function","Event-driven = callbacks on events","Async flow = sequencing tasks without blocking"]},{id:21,question:"Arrow Functions vs Regular Functions: what are key differences?",answer:["Arrow functions use lexical `this` (inherited from surrounding scope).","Regular functions have dynamic `this` (depends on caller).","Arrow functions don't have their own `arguments`; use rest `...args` instead.","Arrow functions are shorter and support implicit return."],example:["const user = {","  name: 'Ani',","  reg: function() { console.log(this.name); },","  arr: () => console.log(this.name)","};","user.reg(); // Ani","user.arr(); // undefined"," ","function regular(a, b) { console.log(arguments[0]); }","regular(1, 2, 3); // 1"," ","const arrow = (...args) => console.log(args);","arrow(1, 2, 3); // [1, 2, 3]"],keyterms:["Lexical this = arrow binds outer this","Dynamic this = regular depends on caller","No arguments in arrow; use rest params"]},{id:22,question:"What are Pure vs Impure Functions?",answer:["Pure: same inputs -> same output, no side effects.","Impure: modifies external state or relies on it.","Pure functions are predictable and testable."],example:["// pure","const add = (a, b) => a + b;"," ","// impure","let total = 0;","function addToTotal(x) {","  total += x;","}"],keyterms:["Pure = deterministic, no side effects","Impure = side effects"]},{id:23,question:"What are closures in JavaScript?",answer:["Function bundled with its lexical environment is called as a closure. ","Closure is when a function remembers variables from its outer scope, even after the outer function has finished. Example: useful in React for preserving state in event handlers.","Even if all the variables of it's parent function vanished in execution context through return or execution. It still remembers the reference it was pointing to.","Its not just that function alone it returns but the entire closure."],example:["function outer(){","  let secret = 'hidden';","  return () => console.log(secret);","}"," ","const fn = outer();","fn(); // 'hidden'"," ","// outer returns the arrow function and that is assigned to fn","// After return outer func's FEC removed from call stack"],keyterms:["Closure = function + its lexical scope","Closures help with data privacy; hoisting affects variable behavior."]},{id:24,question:"What are pros and cons of closures?",answer:["Pros: Encapsulation, Stateful functions, Modularity","Cons: Memory retention, Potential performance issues, Harder debugging"],example:["function makeCounter(){","  let c = 0;","  return () => ++c;","}"," ","const inc = makeCounter();","inc(); // 1","inc(); // 2"],keyterms:["closure = function + its surrounding scope","Encapsulation = hiding variables from outside scope","Stateful function = function remembers values between calls","Modularity = reusable code pattern (callbacks, factories, event handlers)","Memory retention = closures keep referenced variables alive in memory","Performance issue = holding large data unnecessarily can slow down app","Debugging difficulty = harder to trace variables that live longer than expected","GC (Garbage Collection) = automatic memory cleanup by JS engine"]},{id:25,question:"How do closures enable data hiding and encapsulation?",answer:["Variables like `count` live in the lexical scope of `createCounter` and are not directly accessible outside.","Only returned methods (increment, decrement, get) can access and modify the private variable.","Encapsulation is achieved by exposing behavior instead of raw state."],example:["function createCounter(){","  let count = 0; // private","  return {","    increment(){ count++; },                 // shorthand method","    doubleIncrement: () => count += 2,      // arrow function method","    get: function(){ return count; }       // with 'function' keyword","  };","}"," ","const counter = createCounter();","counter.increment();","counter.doubleIncrement();","console.log(counter.get()); // 3"],keyterms:["Encapsulation = hide internal state","Privileged methods = controlled access to private data","Closure = inner function keeps access to outer scope"]},{id:26,question:"How do `let`, `var`, and `const` affect closures?",answer:["`var` → function-scoped, shared across closures (last value retained).","`let` → block-scoped, each closure keeps its own value.","`const` → also block-scoped, behaves like `let` but cannot be reassigned."],example:[`for (var i=0; i<3; i++) {
    setTimeout(() => console.log(i), 100);
  } // 3,3,3`," ",`for (let i=0; i<3; i++) {
    setTimeout(() => console.log(i), 100);
  } // 0,1,2`," ",`for (const i of [10,20,30]) {
    setTimeout(() => console.log(i), 100);
  } // 10,20,30`],keyterms:["closure = function remembers surrounding scope","var = one shared binding","let/const = fresh binding each iteration"]},{id:27,question:"How does setTimeout demonstrate closures (let vs var) with Fix ?",answer:["`let` is block-scoped → each iteration creates a new binding of i, so closures capture the correct value.","`var` is function-scoped → only one i exists for the whole loop, so closures capture the same reference.","By the time setTimeout callbacks run, the loop has finished and i has the final value.","Fix: wrap `var` in an IIFE or use `let` to give each closure its own copy of i."],example:["// Using let (each iteration has its own i)","for (let i = 1; i <= 3; i++) {","  setTimeout(() => console.log(i), i * 1000);","}   // Output: 1, 2, 3"," ","// Using var (one shared i for all iterations)","for (var i = 1; i <= 3; i++) {","  setTimeout(() => console.log(i), i * 1000);","}   // Output: 4, 4, 4",""," ","// Fix for var → use IIFE to capture i","for (var i = 1; i <= 3; i++) {","  (function(i){","    setTimeout(() => console.log(i), i * 1000);","  })(i);","}   // Output: 1, 2, 3"],keyterms:["var = function scope (one binding for loop)","let = block scope (new binding per iteration)","IIFE = captures var value in its own closure"]},{id:28,question:"What are Event Listeners in JavaScript?",answer:["They run a handler when an event occurs (click, input, etc.).","Handlers are callbacks wired to elements or the window.","Multiple listeners can exist per event/element."],example:["document.getElementById('btn')","  .addEventListener('click', () => console.log('Clicked'));"],keyterms:["Listener = callback for an event","addEventListener(type, handler)"]},{id:29,question:"How do closures work with Event Listeners?",answer:["Listeners capture variables from their creation scope.","State can persist across multiple event triggers.","Be mindful: captured state keeps memory alive."],example:["function counter(){","  let count = 0;","  btn.addEventListener('click', () => console.log(++count));","}"," ","counter();"],keyterms:["Closure = function + lexical scope","Stateful listeners via closure"]},{id:30,question:"How does scope affect Event Listeners (var vs let)?",answer:["A function execution context is created only when a function is invoked (added to the call stack).Inside that context, JS maintains a Lexical Environment(variable env)","`var` is function-scoped → one variable shared across all iterations. Whereas`let` is block-scoped → each iteration gets its own copy of the variable.","With `var`, callbacks/event listeners see the final value after the loop. But, with `let`, callbacks/event listeners keep the correct value of each loop iteration.","Because the call stack frame is created only when a function executes, not on every loop iteration. With var, the loop runs inside the same function execution context, so it just reuses the same variable binding. Only let/const trigger creation of a fresh block environment record each iteration."],example:["// Using var → all callbacks share one i","for (var i=1; i<=3; i++){","  setTimeout(()=>console.log(i), 500);","}","// Output: 4,4,4"," ","// Using let → each iteration has its own i","for (let i=1; i<=3; i++){","  setTimeout(()=>console.log(i), 500);","}","// Output: 1,2,3"],keyterms:["var = function scope, shared binding","let = block scope, new binding per loop","closure = function remembers variable from outer scope"]},{id:31,question:"Why should you remove Event Listeners?",answer:["Listeners hold references via closures -> memory use.","Unused listeners can leak memory and slow apps.","Always remove when not needed."],example:["function handle(){ ","console.log('Click'); ","}"," ","btn.addEventListener('click', handle);"," ","// later move it","btn.removeEventListener('click', handle);"],keyterms:["removeEventListener = cleanup","Garbage collection needs no refs"]},{id:32,question:"What are Debouncing and Throttling with event listeners?",answer:["Debounce: delay execution until user stops triggering.","Throttle: limit executions to once per interval.","Both reduce unnecessary handler calls."],example:["// Debounce: wait for pause","function debounce(fn, delay){","  let t;","  return ()=>{ clearTimeout(t); t=setTimeout(fn, delay); };","}","button.onclick = debounce(()=>console.log('Debounced!'), 500);"," ","// Throttle: allow once per delay","function throttle(fn, delay){","  let last=0;","  return ()=>{","    if(Date.now()-last>delay){ fn(); last=Date.now(); }","  };","}","button.onclick = throttle(()=>console.log('Throttled!'), 1000);"],keyterms:["Debounce = wait then run","Throttle = run at fixed rate"]},{id:33,question:"What are synchronous and asynchronous code in JavaScript?",answer:["Synchronous code runs line-by-line, blocking further execution until the current task finishes.","Asynchronous code allows other tasks to run while waiting for an operation to complete, preventing blocking."],example:["// Synchronous","console.log('Start');","console.log('End');"," ","// Asynchronous","console.log('Start');","setTimeout(() => console.log('Async task'), 1000);","console.log('End');"],keyterms:["Synchronous = tasks run one after another, blocking","Asynchronous = tasks run without waiting, non-blocking"]},{id:34,question:"Why is JavaScript called single-threaded and synchronous?",answer:["JS runs on a single main thread executing one task at a time.","By default, code runs synchronously in order.","Global Execution context sits at the bottom of call stack, whenever a new function has to be executed theirs execution context is pushed to call stack, after completion its removed."],example:["console.log('A');","console.log('B');","console.log('C'); // strict order"],keyterms:["Single-threaded = one call stack","Synchronous = sequential execution"]},{id:35,question:"What does blocking the main thread mean in JavaScript?",answer:["A long synchronous task stops the event loop from processing other work.","UI freezes and DOM will not load if that piece of code comes at the beginning, thereby degrading user experience.","Use async patterns or Web Workers or execute that piece of code later when DOM loads properly to avoid blocking."],example:["console.log('Main thread blocking started');"," ","const start = Date.now();","while (Date.now() - start < 5000) {","  // blocks Main Thread for 5 sec","}"," ","console.log('Blocking ended');"],keyterms:["Blocking = main thread is busy","Non-blocking = yields to the loop","Web Workers = Background scripts that run in parallel with main thread"]},{id:36,question:"What is the Event Loop in JavaScript and how does it work?",answer:["The event loop is the mechanism that enables JavaScript (a single-threaded language) to handle asynchronous operations without blocking.","It constantly checks the call stack and queues to decide what to execute next, as soon as call stack becomes empty.","Microtask Queue: higher-priority queue for promises, MutationObserver, and queueMicrotask. Runs right after the current call stack is empty.","Callback/Task Queue: lower-priority queue for tasks like setTimeout, setInterval, DOM events, and network callbacks. Runs only after microtasks finish.","Concurrency Model: how JS manages multiple tasks without parallel threads, with the help of Event Loop which schedules task bw call stack and queues."],example:["console.log('Start');"," ","setTimeout(() => console.log('Task Queue: Timeout'), 0);"," ","Promise.resolve().then(() => console.log('Microtask Queue: Promise'));"," ","console.log('End');"," ","// Output order:","// Start → End → Microtask Queue: Promise → Task Queue: Timeout"],keyterms:["Event Loop = decides execution order of tasks","Call Stack = executes synchronous code","Microtask Queue = promises, MutationObserver (high priority)","Callback/Task Queue = setTimeout, events, I/O (lower priority)","Order = synchronous code → microtasks → tasks (callbacks)."]},{id:37,question:"What is the difference between Microtask Queue and Callback/Task Queue in JavaScript event loop?",answer:["Microtask Queue has higher priority — promises, MutationObserver, and queueMicrotask go here.","Callback/Task Queue is lower priority — setTimeout, setInterval, DOM events, and other async APIs go here.","After each synchronous code execution, the event loop empties the Microtask Queue before moving to the Callback/Task Queue.","This ensures promises resolve before timeouts and DOM callbacks."],example:["let fn = () => console.log('callback func');","setTimeout(fn, 1);"," ","fetch('https://jsonplaceholder.typicode.com/users').then((res) =>","  console.log('promise resolved')",");"],keyterms:["Microtask Queue = promises, MutationObserver, queueMicrotask","Callback/Task Queue = setTimeout, setInterval, DOM events","Priority = microtasks run before tasks"]},{id:38,question:"How do you handle asynchronous code using callbacks in JavaScript?",answer:["Callbacks pass a function as an argument to execute after an async task.","Simple for basic async, but can nest deeply."],example:["function callbackDemo() {","  setTimeout(() => console.log('Hello from Callback!'), 1000);","  console.log('Start');","}","callbackDemo(); "," ","// Output: 'Start' immediately, then 'Hello from Callback!' after 1s"],keyterms:["Callback = passed function","Async execution"]},{id:39,question:"How do you handle asynchronous code using Promises in JavaScript?",answer:["Promises represent async results; use .then() for success and .catch() for errors.","Code after a Promise runs immediately while the Promise is pending, showing async behavior.","Explanation of example:","1. `promiseDemo` resolves after 1 second.","2. `.then()` runs when the Promise resolves.","3. `console.log('Start')` runs immediately, before the resolved message.","4. `.catch()` handles errors if rejected."],example:["const promiseDemo = new Promise(res =>","  setTimeout(() => res('Hello from Promise!'), 1000)",");"," ","promiseDemo","  .then(msg => console.log(msg)) ","  .catch(err => console.error(err));"," ","console.log('Start');"," ","// Output: 'Start' immediately, then 'Hello from Promise!' after 1s"],keyterms:[".then/.catch = handlers","Async execution = code runs while Promise is pending"]},{id:40,question:"How do you handle asynchronous code using async/await in JavaScript?",answer:["async/await pauses execution until a Promise resolves, making async code look synchronous and easier to read than chaining .then() with Promises.","Code after await (or after calling the async function) can run immediately, demonstrating async behavior.","Explanation of example:","1. `wait(ms)` returns a Promise that resolves after `ms` ms.","2. `await wait(1000)` pauses the async function for 1 second.","3. Errors can be handled with try/catch (optional if using .catch() outside)."],example:["function wait(ms) {","  return new Promise(res => setTimeout(() => res('async/await!'), ms));","}"," ","async function AsyncDemo() {","  const msg = await wait(1000);","  console.log(msg);  ","}"," ","AsyncDemo();","console.log('Start'); "," ","// Output: 'Start' immediately, then 'async/await!' after 1s"],keyterms:["Async/await = sync-like","Await = pause"]},{id:41,question:"Compare callbacks, promises, and async/await in JavaScript.",answer:["Callbacks: Oldest way, pass a function to handle async result. Simple but leads to nesting (callback hell).","Promises: Provide a cleaner async model by flattening the structure with .then() chaining, improving readability","Async/await: Built on promises, makes async code look synchronous, avoiding chaining entirely, gives sync-like code and better readability."],example:["Style      | Handling result     | Pros                 | Cons                   ","-----------|---------------------|----------------------|------------------------","Callback   | Inside callback fn  | Simple, built-in     | Callback hell, messy   ","Promise    | .then()/.catch()    | Cleaner, chaining    | Verbose for many steps ","Async/Await| await inside async  | Readable, looks sync | Must be in async fn    "],keyterms:["Promise = .then/.catch chaining","Async/await = modern, cleaner syntax","Callback hell = happens when callbacks are nested deeply, making code hard to read and maintain."]},{id:42,question:"What is starvation of tasks in the Callback Queue in JavaScript?",answer:["Starvation happens when tasks in the Callback/Task Queue (like setTimeout, events) keep getting delayed.","This occurs if microtasks (promises, MutationObserver) continuously create new microtasks.","Since the event loop always empties the Microtask Queue before moving to the Callback Queue, endless microtasks can starve callback tasks.","This leads to timers, DOM events, or I/O callbacks being blocked indefinitely."],example:["console.log('Start');"," ","function endlessMicrotask() {","  Promise.resolve().then(() => {","    console.log('Microtask running');","    endlessMicrotask(); // schedules another microtask endlessly","  });","}"," ","endlessMicrotask();"," ","setTimeout(() => console.log('Task Queue: Timeout'), 0);"," ","// Output:","// Start → Microtask running → Microtask running → ... (infinite)","// Timeout never runs (starved)"],keyterms:["Starvation = when lower-priority tasks never get CPU time","Microtask Queue = higher priority, can block tasks if abused","Callback/Task Queue = lower priority, may starve if microtasks never finish"]},{id:43,question:"What is the map() method in JavaScript?",answer:["map() creates a new array by applying a transformation function to each element.","It does not modify the original array.","Commonly used for data transformation, like extracting fields or converting values."],example:["const numbers = [1, 2, 3, 4];"," ","const squared = numbers.map(n => n * n);"," ","console.log(squared); // [1, 4, 9, 16]"],keyterms:["map = transform all elements","Returns new array = same length as input","Pure function = no mutation of original array"]},{id:44,question:"What is the filter() method in JavaScript?",answer:["filter() creates a new array with only elements that pass the provided condition.","Does not change the original array.","Useful for extracting subsets of data."],example:["const numbers = [10, 15, 20, 25, 30];"," ","const evens = numbers.filter(n => n % 2 === 0);"," ","console.log(evens); // [10, 20, 30]"],keyterms:["filter = pick elements matching condition","Returns new array = length ≤ original","Condition function = returns true/false"]},{id:45,question:"What is the reduce() method in JavaScript?",answer:["reduce() applies a reducer function to all elements of an array, returning a single accumulated result.","Takes two arguments: a callback (with accumulator and current value) and an initial value.","Common use cases: sum, average, max/min, object grouping."],example:["const prices = [5, 10, 15];","const total = prices.reduce((acc, curr) => acc + curr, 0);","console.log(total); // 30"," ","const maxVal = prices.reduce((max, curr) => curr > max ? curr : max, 0);","console.log(maxVal); // 15"],keyterms:["reduce = compress array into single value","Accumulator = stores running result","Initial value = starting point for accumulator"]},{id:46,question:"What is a Polyfill for map, filter, and reduce, and how to implement it?",answer:["A polyfill is custom code that adds support for a feature if it is not available in a browser.","Polyfills ensure older environments can still use modern array methods.","For map, filter, and reduce, polyfills mimic their original behavior using for-loops."],example:["// Polyfill for map"," ","if (!Array.prototype.myMap) {","  Array.prototype.myMap = function(cb) {","    const result = [];","    for (let i = 0; i < this.length; i++) {","      result.push(cb(this[i], i, this));","    }","    return result;","  };","}"," ","const nums = [1, 2, 3];","const doubled = nums.myMap(n => n * 2);","console.log(doubled); // [2, 4, 6]"],keyterms:["Polyfill = custom implementation of a feature","Needed for backward compatibility","Implemented by extending prototypes (like Array.prototype)"]},{id:47,question:"What is Memoization and how does it use closures?",answer:["Caching function results to avoid recomputation.","Closure keeps a private cache map/object.","Great for expensive pure functions."],example:["function memoize(fn) {","  const cache = {};","  return n => cache[n] ?? (cache[n] = fn(n));","}"," ","const slowSquare = n => {","  for (let i = 0; i < 1e6; i++) {}","  return n * n;","};"," ","const fastSquare = memoize(slowSquare);"],keyterms:["Memoization = cache results","Closure holds cache"]},{id:48,question:"Which is more common in JavaScript: OOP or Functional Programming, and why?",answer:["Both paradigms exist in JavaScript, but functional programming is more common in day-to-day code.","JavaScript treats functions as first-class citizens, making it natural to use map, filter, reduce, callbacks, and promises.","OOP (with classes/objects) is still used, especially for structuring large applications and frameworks (like React classes before hooks).","Modern JS often uses a mix: functional style for data handling, OOP for app architecture."],example:["// Functional style","[1, 2, 3].map(x => x * 2); // [2, 4, 6]"," ","// OOP style","class Counter {","  constructor() { this.value = 0; }","  inc() { this.value++; }","}","const c = new Counter();","c.inc(); console.log(c.value); // 1"],keyterms:["Functional programming = uses functions as primary building blocks","OOP = organizes code into objects/classes","JavaScript = multi-paradigm (supports both)"]},{id:49,question:"What is Object-Oriented Programming (OOP) in JavaScript and what are its main principles?",answer:["OOP in JavaScript is a programming paradigm where data (objects) and behavior (methods) are bundled together.","JS supports OOP using prototypes and classes.","The 4 key principles are: Encapsulation, Abstraction, Inheritance, and Polymorphism."],keyterms:["OOP = programming paradigm combining data and behavior in objects","Encapsulation = binding data with methods and keeping them private","Abstraction = hiding implementation details and exposing only necessary interfaces","Inheritance = reusing properties/methods from parent objects","Polymorphism = ability of a method to take multiple forms depending on context"]},{id:50,question:"How is Encapsulation achieved in JavaScript?",answer:["Encapsulation means keeping data (variables) safe from direct access and exposing only necessary methods.","Achieved using closures or private fields (#) inside classes."],example:["class BankAccount {","  #balance = 0;","  deposit(amount) { this.#balance += amount; }","  getBalance() { return this.#balance; }","}"," ","const acc = new BankAccount();","acc.deposit(500);","console.log(acc.getBalance()); // 500"],keyterms:["Private field = variable not directly accessible","Encapsulation = data hiding with controlled access"]},{id:51,question:"What is Abstraction in JavaScript?",answer:["Abstraction means exposing only necessary features while hiding details.","In JS, achieved via abstract base classes or by designing APIs that hide implementation."],example:["class Car {","  start() { console.log('Car started'); }","  stop() { console.log('Car stopped'); }","  // details like fuel injection are hidden","}"," ","const c = new Car();","c.start(); // Car started"],keyterms:["Abstraction = hide details, show essentials","API design = practical abstraction"]},{id:52,question:"What is Inheritance in JavaScript?",answer:["Inheritance allows one class to acquire properties and methods of another class.","In JavaScript, achieved using 'extends' keyword with classes or Object.create with prototypes."],example:["class Animal {","  speak() { console.log('Animal sound'); }","}"," ","class Dog extends Animal {","  speak() { console.log('Woof!'); }","}"," ","new Dog().speak(); // 'Woof!'"],keyterms:["extends = keyword for class inheritance","Prototype chain = mechanism behind inheritance"]},{id:53,question:"What is Polymorphism in JavaScript?",answer:["Polymorphism means the same method name can behave differently based on the object.","In JavaScript, achieved by method overriding or using dynamic typing."],example:["class Shape { area() { return 0; } }"," ","class Circle extends Shape {","  constructor(r) { super(); this.r = r; }","  area() { return Math.PI * this.r * this.r; }","}"," ","class Square extends Shape {","  constructor(s) { super(); this.s = s; }","  area() { return this.s * this.s; }","}"," ","console.log(new Circle(3).area()); // 28.27","console.log(new Square(4).area()); // 16"],keyterms:["Polymorphism = multiple forms of same method","Overriding = redefining parent method in child"]},{id:54,question:"How do functions relate to constructors and prototypes in JavaScript?",answer:["Functions can be used with `new` as constructors to create object instances.","Methods can be placed on `FunctionName.prototype` to share across all instances, saving memory.","Each instance can still have its own properties, but methods on prototype are shared."],example:["function Person(name) {","  this.name = name;","}"," ","Person.prototype.sayHi = function() {","  console.log('Hi ' + this.name);","};"," ","const ani = new Person('Ani');","ani.sayHi(); // Hi Ani"],keyterms:["Constructor = function used with new to create objects","Prototype = object shared among all instances","Prototype chain = lookup path JS uses for inherited properties/methods"]},{id:55,question:"What is the difference between prototypal and classical inheritance in JavaScript?",answer:["Classical → objects inherit from classes (like Java, C++).","Prototypal → objects inherit directly from other objects.","JS internally uses prototypal inheritance, though `class` syntax is syntactic sugar."],example:["// Classical style","class Animal { speak() { console.log('sound'); } }","class Dog extends Animal { speak() { console.log('woof'); } }","new Dog().speak(); // woof"," ","// Prototypal style","const animal = { speak() { console.log('sound'); } };","const dog = Object.create(animal);","dog.speak = () => console.log('woof');","dog.speak(); // woof"],keyterms:["Prototype = parent object from which others inherit","Prototype chain = path JS uses to look up inherited properties","Classical inheritance = class-based, blueprint-like inheritance","Prototypal inheritance = object-to-object inheritance"]},{id:56,question:"What is Prototyping in JavaScript?",answer:["Prototyping is the process of adding new methods or properties to built-in objects through their prototype.","When added to the prototype, the method becomes available to all instances of that object type.","It allows extending JavaScript’s core objects, though modifying built-in prototypes in production is generally discouraged."],example:["// Add a custom method to String prototype"," ","String.prototype.reverse = function () {","  return this.split('').reverse().join('');","};"," ","console.log('hello'.reverse()); // 'olleh'"],keyterms:["Prototype = object that other objects inherit from","Prototyping = extending core objects with new methods","Instance = any object created from a constructor (e.g., string, array)"]},{id:57,question:"What is smart garbage collection in modern JavaScript engines?",answer:["Modern JS engines have garbage collectors that automatically free memory used by variables no longer accessible.","Smart garbage collection can detect variables inside closures that are no longer used and release them, even if the closure itself exists.","This prevents memory leaks in long-running applications where closures retain references unnecessarily.","Smart collectors optimize performance by reducing memory usage without waiting for the entire closure to go out of scope."],example:["function createCounter() {","  let count = 0; // local variable inside closure","  return function() {","    console.log('Incremented'); // 'count' is never used","  };","}"," ","const counter = createCounter();","counter();","// Modern garbage collectors may free 'count' memory since it's not used"],keyterms:["Garbage Collector = automatically frees memory for unreachable objects, Uses mark-and-sweep;","Closure = hinder by retaining references.","Smart GC = detects unused variables inside closures and cleans them early","Memory Leak = retained memory that is no longer needed"]},{id:58,question:"How do Closures Affect Garbage Collection?",answer:["Closures allocate a lot of memory which cannot be deleted so this acts as a disadvantage.","Retain outer vars, preventing GC until closure discarded."],example:["function outer() {","  let data = new Array(1e6);","  return () => data;","}"," ","const closure = outer(); // data retained"],keyterms:["Closure = memory hold","Disadvantage = leak risk"]},{id:59,question:"Why Remove Event Listeners for Garbage Collection?",answer:["Unused variables are automatically deleted... Closures allocate a lot of memory which cannot be deleted.","Some browsers now have smart garbage collectors that automatically deletes variables that are not used outside closures.","Removing listeners releases closure refs for GC."],example:["element.removeEventListener('click', handler); // Frees memory"],keyterms:["Smart GC = auto delete","Listener remove = GC aid"]},{id:60,question:"What is the Mark-and-Sweep algorithm in garbage collection?",answer:["It is a tracing garbage collection technique used in JS engines.","It has two phases: Mark and Sweep.","Mark phase: all reachable objects are marked as 1 using DFS traversal.","Sweep phase: objects still marked as 0 are deleted from heap memory.","After sweeping, all reachable objects are reset to 0 for the next cycle."],keyterms:["Mark phase = identifies reachable objects via DFS","Sweep phase = removes unreachable objects","Heap memory = memory area where objects are stored","DFS (Depth-First Search) = traversal method used to mark reachable objects","Tracing GC = garbage collector that works by tracing object references"]},{id:61,question:"Is JavaScript compiled or interpreted? Explain Google Chrome's V8 execution pipeline.",answer:["JavaScript is a high-level language that is both interpreted and compiled (Just-In-Time compilation).","V8 engine first parses JS code into an Abstract Syntax Tree (AST) to understand the program structure.","Ignition, the interpreter, converts the AST into bytecode and starts execution quickly (baseline performance).","Turbofan, the optimizing compiler, monitors running code and compiles hot functions into highly optimized machine code for faster execution.","This pipeline allows JavaScript to start running immediately while still achieving high performance for frequently used code."],example:["// JS code","let sum = (a, b) => a + b;","console.log(sum(5, 10)); // 15"," ","// V8 execution:","// 1. Parser → creates AST","// 2. Ignition Interpreter → generates bytecode and executes","// 3. Turbofan Compiler → optimizes hot code into machine code"],keyterms:["Compiled vs Interpreted = JS uses JIT compilation (both)","Parser = converts code into Abstract Syntax Tree (AST)","AST = tree representation of code structure","Ignition = baseline interpreter producing bytecode","Turbofan = optimizing compiler for hot code","Bytecode = low-level instructions executed by V8"]},{id:62,question:"What are some key memory and performance optimizations in JavaScript engines?",answer:["Mark-and-Sweep: Garbage collector marks reachable objects and deletes unmarked ones to free memory.","Inlining: Functions are replaced by their body in hot code to reduce call overhead.","Copy Elision: Avoids unnecessary copying of objects/values when returning or passing them.","Inline Caching: Caches property access patterns for faster repeated object property lookups."],example:["// Mark-and-Sweep","let obj = {a: 1};","obj = null; // unreachable → collected by GC"," ","// Inlining","function add(a,b){ return a+b; }","// JS engine may replace add(x,y) with x+y"," ","// Copy Elision","function createPoint(){ return {x:0, y:0}; }","// engine avoids extra copying of object"," ","// Inline Caching","let obj = {name:'Ani'};","console.log(obj.name);","// engine caches property lookup for speed"],keyterms:["Mark-and-Sweep = GC deletes unreachable memory","Inlining = replaces function calls with body","Copy Elision = avoids unnecessary copies","Inline Caching = caches property access paths for speed"]},{id:63,question:"What is the difference between Web Worker and Service Worker in JavaScript?",answer:["Web Worker runs background threads for heavy computations (keeps UI responsive).","Service Worker acts as a proxy between browser & network (handles caching, offline support, push notifications).","Web Worker has no direct access to DOM, Service Worker also cannot access DOM but can intercept network requests.","Web Worker ends when the page is closed, Service Worker persists beyond page (event-driven, works even when page is closed)."],example:["// Web Worker Example","const worker = new Worker('worker.js');","worker.postMessage('start');","worker.onmessage = e => console.log(e.data);"," ","// Service Worker Example","navigator.serviceWorker.register('/sw.js');","self.addEventListener('fetch', event => {","  event.respondWith(fetch(event.request));","});"],keyterms:["Web Worker = Background thread for computation","Service Worker = Proxy layer for caching, offline, push","Thread = Separate execution flow","Event-driven = Reacts to events like fetch, push"]}];export{e as default};
