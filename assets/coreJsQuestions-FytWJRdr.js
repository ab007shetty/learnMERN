const e=[{id:1,question:"What is the difference between let, const, and var in JavaScript?",answer:["Prefer const by default since it prevents accidental reassignments.","Use let only when a variable’s value truly needs to change like reassignments.","Avoid var since it is function-scoped, hoisted with undefined, so prone to bugs.","Always declare variables at the top of their block to avoid TDZ."],example:["      | Scope          | Hoisting          | Reassign    | Redeclare","------|----------------|-------------------|-------------|------------","var   | Function scope | Yes (undefined)   | Allowed     | Allowed","let   | Block scope    | Yes (TDZ applies) | Allowed     | Not allowed","const | Block scope    | Yes (TDZ applies) | Not allowed | Not allowed"],keyterms:["Scope = area where variable is accessible (function or block)","Hoisting = variables moved to top of scope before execution","TDZ (Temporal Dead Zone) = period after hoisting but before initialization; accessing variable throws error"]},{id:2,question:"What are primitive and non-primitive data types in JavaScript?",answer:["Primitive types are immutable and hold single values. Examples: string, number, boolean, null, undefined, symbol, bigint.","Non-primitive types (reference types) store collections or objects, and are mutable. Examples: object, array, function.","Key Differences:"],example:["Feature           | Primitive        | Non-Primitive","------------------|----------------- |--------------------------","Stored as         | Value            | Reference (in memory)","Mutable           | No               | Yes","Compared by       | Value            | Reference"],keyterms:["In React: Primitives are used in state; non-primitives (like objects/arrays) require careful handling to avoid unwanted re-renders."]},{id:3,question:"What is Recursion and when should you use it?",answer:["A function calling itself to solve smaller subproblems.","Useful for tree/graph traversals, divide-and-conquer.","Tail-call optimization isn’t guaranteed in most JS engines."],example:["function fact(n) {","  if (n <= 1) {","    return 1;","  } else {","    return n * fact(n - 1);","  }","}","console.log(fact(5)); // 120"],keyterms:["Recursion = self-calling function","TCO (Tail Call Optimization) = not reliable in JS"]},{id:4,question:"What are template literals in JavaScript?",answer:["Template literals are strings enclosed by backticks (`) that allow embedded expressions and multi-line strings.","They use ${} for interpolation, making it easy to insert variables or expressions directly in a string."],example:["const name = 'John';","console.log(`Hello, ${name}!`); // Hello, John!"],keyterms:["Template literal = string with backticks (`) supporting expressions and multi-line text","Interpolation = inserting values using ${expression}"]},{id:5,question:"What is the difference between spread and rest operators in JavaScript?",answer:["Spread operator (...) expands an iterable (like array or object) into individual elements.","Rest operator (...) collects multiple elements into an array, often used in function parameters."],example:["// Spread Operator","const arr = [1, 2];","const newArr = [...arr, 3]; // [1, 2, 3]"," ","// Rest Operator","function sum(...args) {","  return args.reduce((a, b) => a + b, 0);","}"],keyterms:["Both use ... but differ by context: spread expands, rest collects. Used heavily in React for props and state management."]},{id:6,question:"What is the difference between Parameters and Arguments?",answer:["Parameters are placeholders in the function definition.","Arguments are actual values passed during the call.","Arity = number of declared parameters."],example:["function add(a, b) {","  return a + b; // a, b = parameters","}"," ","add(4, 5); // 4, 5 = arguments"],keyterms:["Parameter = declared variable","Argument = runtime value"]},{id:7,question:"What are default parameters and rest parameters?",answer:["Default parameters give fallback values when args are missing.","To trigger a default param, you must pass `undefined` explicitly.","Rest parameters collect remaining args into an array.","Use rest instead of `arguments` for clarity."],example:["(function (name = 'ani', b) {","  console.log(name + b);","})(undefined, ' shetty'); // ani shetty"," ","function greet(name = 'Guest') {","  return 'Hi ' + name;","}"," ","function sum(...nums) {","  return nums.reduce((a, b) => a + b, 0);","}"],keyterms:["Default params = fallback","Rest params = variable arity","undefined = triggers default param"]},{id:8,question:"What is the difference between deep copy and shallow copy in JavaScript?",answer:["Shallow copy copies only the first level of an object/array; nested objects still reference the original.","Deep copy copies all nested levels, creating a fully independent clone."],example:["let obj= [1,2,[3,4]]"," ","const copy = {...obj}; // shallow copy"," ","const deepCopy = JSON.parse(JSON.stringify(obj));"," ","console.log(copy)","console.log(deepCopy)"],keyterms:["Shallow copy = top-level copy, nested references shared.","Deep copy = fully independent clone of all nested data. In React, shallow copies are often used for state updates, but deep copies are needed when nested objects change."]},{id:9,question:"What is hoisting and how do var, let, and const behave differently in JavaScript?",answer:["Hoisting is JavaScript’s behavior of moving variable declarations to the top of their scope.","var is hoisted and initialized as undefined.","let and const are also hoisted, but not initialized. They stay in the Temporal Dead Zone (TDZ) until their declaration is reached.","Accessing let or const before declaration causes a ReferenceError."],example:["      | Hoisted? | Initialized? | TDZ Exists? | Access Before Declaration","------|----------|--------------|-------------|---------------------------","var   | Yes      | Yes (undef)  | No          | Allowed (undefined)","let   | Yes      | No           | Yes         | Error in TDZ","const | Yes      | No           | Yes         | TDZ + Must initialize "]},{id:10,question:"What is the Temporal Dead Zone (TDZ) in JavaScript?",answer:["The Temporal Dead Zone is the period between entering a scope and the point where a let or const variable is declared.","It starts when the execution context is created (hoisting happens) and ends when the execution phase reaches the actual declaration line where the variable is initialized."],example:["console.log(a); // ReferenceError"," ","let a = 5;"],keyterms:["TDZ = period between a variable’s hoisting and its initialization.","Prevents access to variables before they're defined","Applies only to let and const, not var. TDZ helps avoid bugs by enforcing proper variable declaration order."]},{id:11,question:"Why are functions called first-class citizens in JavaScript?",answer:["Functions can be assigned to variables.","Functions can be passed as arguments.","Functions can be returned from other functions.","Functions can be stored in objects or arrays."],example:["// assign to variable","const greet = function() { return 'Hello'; };"," ","// pass as argument","function run(fn) { console.log(fn()); }","run(greet); // 'Hello'"," ","// return a function","function outer() { return () => 'Inner'; }","const inner = outer();","console.log(inner()); // 'Inner'"],keyterms:["First-class citizens = treated like values","Functions = assign, pass, return, store"]},{id:12,question:"What is a Function Statement (Declaration) and how does hoisting work?",answer:["A named function defined with the function keyword at top level or inside scopes.","Function declarations are hoisted with their definitions.","You can call them before their appearance in code."],example:["foo();               // This works"," ","function foo() {","  console.log('Hi');","}"],keyterms:["Function declaration = hoisted","Hoisting = definition available earlier"]},{id:13,question:"What is a Function Expression and how is it hoisted?",answer:["A function assigned to a variable/constant.","Only the variable is hoisted (initialized later).","Calling before assignment causes error."],example:["bar(); // TypeError/undefined at call time"," ","var bar = function() {","  console.log('Hi');","};"],keyterms:["Function expression = not fully hoisted","Declaration vs expression hoisting"]},{id:14,question:"What is an Anonymous Function and where is it used?",answer:["A function without a name.","Common in callbacks and IIFEs.","Useful when the function is not reused."],example:["setTimeout(function() {","  console.log('Timer');","}, 500);"],keyterms:["Anonymous = no name","Used as inline callback"]},{id:15,question:"What is an IIFE (Immediately Invoked Function Expression) and how is it different from function currying?",answer:["IIFE is a function that runs immediately after being defined.","It uses ()() syntax → one pair for wrapping, one pair for execution.","Function currying is when a function returns another function and parameters are passed step by step.","Syntax looks similar, but currying delays execution until further calls."],example:["// Example 1: IIFE"," ","(function() {","  console.log('I run immediately!');","})();"," ","// Example 2: Currying"," ","function multiply(a) {","  return function(b) {","    return a * b;","  }","}","console.log(multiply(4)(5)); // 20"],keyterms:["IIFE = Function that executes immediately after creation","Currying = Breaking a function with multiple params into nested functions","()() = Syntax used for both, but purpose differs"]},{id:16,question:"What is Function Currying?",answer:["Transforming a function of n args into a chain of unary functions.","Uses closures to remember earlier arguments.","Useful for partial application and composition."],example:["const add = a => b => a + b;","add(2)(3); // 5"],keyterms:["Currying = f(a,b)->f(a)(b)","Partial application"]},{id:17,question:"What is infinite currying in JavaScript?",answer:["Infinite currying is a function technique where a function keeps returning another function, allowing repeated calls with new arguments.","It usually ends when a condition is met, such as receiving no arguments, at which point it returns the final result."],example:["function add(a) {","  return function(b) {","    if (b !== undefined) return add(a + b);","    return a;","  };","}"," ","console.log(add(1)(2)(3)()); // 6"],keyterms:["Currying = breaking a function with multiple args into a chain of single-arg functions","Infinite currying = currying without a fixed number of arguments, ends with a stop condition"]},{id:18,question:"What is a Named Function Expression and why use it?",answer:["A function expression with an internal name.","Improves stack traces and allows self-recursion.","Name is not available in the outer scope."],example:["const a = function xyz(n){","  if(n<=1) return 1;","  return n*xyz(n-1);","};"," ","a(3); // ok, xyz is not global"],keyterms:["Named expression = inner name only","Better debugging, recursion"]},{id:19,question:"What is array destructuring in JavaScript and why is it used?",answer:["Array destructuring allows extracting values from arrays and assigning them to variables in a single line.","It makes code shorter and easier to read.","You can skip elements or set default values."],example:["const arr = [1, 2, 3];","const [a, b, c] = arr;","console.log(a, b, c); // 1 2 3","","// Skipping and default value","const [x, , z = 10] = [5];","console.log(x, z); // 5 10"],keyterms:["Destructuring = unpacking values from arrays/objects","Default value = assigned if no value present"]},{id:20,question:"What are the types of exports in JavaScript modules and how do they differ?",answer:["There are two types: **Default Export** and **Named Export**.","Default export → only one per file, can be imported with any name.","Named export → multiple per file, must use same name when importing."],example:["// Default export","export default function greet() { console.log('Hello'); }","import hello from './greet.js';","hello();","","// Named export","export const add = (a,b) => a + b;","import { add } from './math.js';","console.log(add(2,3)); // 5"],keyterms:["Default export = single main export per file","Named export = multiple exports with exact names"]},{id:21,question:"What is Optional Chaining (?.) in JavaScript and why is it used?",answer:["Optional chaining (?.) allows safe access to nested object properties.","It prevents runtime errors if a property doesn’t exist.","If any property in the chain is null or undefined, it returns undefined instead of throwing an error.","Useful for handling deeply nested data safely."],example:["const user = { profile: { name: 'Ani' } };","console.log(user.profile?.name); // Ani","console.log(user.address?.city); // undefined (no error)","","// Without optional chaining → Error","// console.log(user.address.city); // ❌ TypeError"],keyterms:["Optional chaining = safe property access operator","?. = returns undefined if property doesn’t exist","Avoids = runtime TypeError"]},{id:22,question:"What are First-Class and Higher-Order Functions in JavaScript?",answer:["First-class functions: Functions are treated like variables. They can be assigned, passed as arguments, or returned.","Higher-order functions (HOF): A function that takes one or more functions as arguments (callbacks), or returns a function.","The function passed as an argument is called a callback, and the function receiving it is called the higher-order function."],example:["const radius = [3, 1, 2, 4];"," ","const area = function (r) {","  return Math.PI * r * r;","};"," ","const calculate = function (radiusArr, logic) {","  const output = [];","  for (let i = 0; i < radiusArr.length; i++) {","    output.push(logic(radiusArr[i]));","  }","  return output;","};"," ","console.log(calculate(radius, area)); // [28.27, 3.14, 12.56, 50.27]"],keyterms:["First-class = functions as values (assign, pass, return)","Higher-order = takes/returns functions","Callback = function passed to HOF","DRY principle = Don't Repeat Yourself (reuse logic)"]},{id:23,question:"What are Higher-Order Functions (HOF) in JavaScript and why are they used?",answer:["A Higher-Order Function is a function that takes another function as an argument or returns one.","They help in code reuse and functional programming style.","Examples include map(), filter(), reduce()."],example:["const nums = [1, 2, 3, 4];","const squares = nums.map(n => n * n);","console.log(squares); // [1, 4, 9, 16]"],keyterms:["HOF = function that takes or returns another function","map, filter, reduce = common HOFs"]},{id:24,question:"What is a Callback Function in JavaScript and its top use cases?",answer:["A callback is a function passed as an argument to another function.","It executes later, typically after an operation completes.","Common use cases: timers (setTimeout), event listeners, network requests, and sequencing async tasks.","Callbacks enable async programming and support event-driven designs in JavaScript."],example:["document.getElementById('btn').addEventListener('click', () => {","  btn.innerText = 'clicked';","  console.log('Btn clicked');"," ","  setTimeout(() => {","    btn.innerText = 'Click Me';","  }, 1000);","});"],keyterms:["Callback = function passed to another function","Event-driven = callbacks on events","Async flow = sequencing tasks without blocking"]},{id:25,question:"Arrow Functions vs Regular Functions: what are key differences?",answer:["Arrow functions use lexical `this` (inherited from surrounding scope).","Regular functions have dynamic `this` (depends on caller).","Arrow functions don't have their own `arguments`; use rest `...args` instead.","Arrow functions are shorter and support implicit return."],example:["const user = {","  name: 'Ani',","  reg: function() { console.log(this.name); },","  arr: () => console.log(this.name)","};","user.reg(); // Ani","user.arr(); // undefined"," ","function regular(a, b) { console.log(arguments[0]); }","regular(1, 2, 3); // 1"," ","const arrow = (...args) => console.log(args);","arrow(1, 2, 3); // [1, 2, 3]"],keyterms:["Lexical this = arrow binds outer this","Dynamic this = regular depends on caller","No arguments in arrow; use rest params"]},{id:26,question:"What are Pure vs Impure Functions?",answer:["Pure: same inputs -> same output, no side effects.","Impure: modifies external state or relies on it.","Pure functions are predictable and testable."],example:["// pure","const add = (a, b) => a + b;"," ","// impure","let total = 0;","function addToTotal(x) {","  total += x;","}"],keyterms:["Pure = deterministic, no side effects","Impure = side effects"]},{id:27,question:"What are closures in JavaScript?",answer:["Function bundled with its lexical environment is called as a closure. ","Closure is when a function remembers variables from its outer scope, even after the outer function has finished. Example: useful in React for preserving state in event handlers.","Even if all the variables of it's parent function vanished in execution context through return or execution. It still remembers the reference it was pointing to.","Its not just that function alone it returns but the entire closure."],example:["function outer(){","  let secret = 'hidden';","  return () => console.log(secret);","}"," ","const fn = outer();","fn(); // 'hidden'"," ","// outer returns the arrow function and that is assigned to fn","// After return outer func's FEC removed from call stack"],keyterms:["Closure = function + its lexical scope","Closures help with data privacy; hoisting affects variable behavior."]},{id:28,question:"What are pros and cons of closures?",answer:["Pros: Encapsulation, Stateful functions, Modularity","Cons: Memory retention, Potential performance issues, Harder debugging"],example:["function makeCounter(){","  let c = 0;","  return () => ++c;","}"," ","const inc = makeCounter();","inc(); // 1","inc(); // 2"],keyterms:["closure = function + its surrounding scope","Encapsulation = hiding variables from outside scope","Stateful function = function remembers values between calls","Modularity = reusable code pattern (callbacks, factories, event handlers)","Memory retention = closures keep referenced variables alive in memory","Performance issue = holding large data unnecessarily can slow down app","Debugging difficulty = harder to trace variables that live longer than expected","GC (Garbage Collection) = automatic memory cleanup by JS engine"]},{id:29,question:"How do closures enable data hiding and encapsulation?",answer:["Variables like `count` live in the lexical scope of `createCounter` and are not directly accessible outside.","Only returned methods (increment, decrement, get) can access and modify the private variable.","Encapsulation is achieved by exposing behavior instead of raw state."],example:["function createCounter(){","  let count = 0; // private","  return {","    increment(){ count++; },                 // shorthand method","    doubleIncrement: () => count += 2,      // arrow function method","    get: function(){ return count; }       // with 'function' keyword","  };","}"," ","const counter = createCounter();","counter.increment();","counter.doubleIncrement();","console.log(counter.get()); // 3"],keyterms:["Encapsulation = hide internal state","Privileged methods = controlled access to private data","Closure = inner function keeps access to outer scope"]},{id:30,question:"How do `let`, `var`, and `const` affect closures?",answer:["`var` → function-scoped, shared across closures (last value retained).","`let` → block-scoped, each closure keeps its own value.","`const` → also block-scoped, behaves like `let` but cannot be reassigned."],example:[`for (var i=0; i<3; i++) {
    setTimeout(() => console.log(i), 100);
  } // 3,3,3`," ",`for (let i=0; i<3; i++) {
    setTimeout(() => console.log(i), 100);
  } // 0,1,2`," ",`for (const i of [10,20,30]) {
    setTimeout(() => console.log(i), 100);
  } // 10,20,30`],keyterms:["closure = function remembers surrounding scope","var = one shared binding","let/const = fresh binding each iteration"]},{id:31,question:"How does setTimeout demonstrate closures (let vs var) with Fix ?",answer:["`let` is block-scoped → each iteration creates a new binding of i, so closures capture the correct value.","`var` is function-scoped → only one i exists for the whole loop, so closures capture the same reference.","By the time setTimeout callbacks run, the loop has finished and i has the final value.","Fix: wrap `var` in an IIFE or use `let` to give each closure its own copy of i."],example:["// Using let (each iteration has its own i)","for (let i = 1; i <= 3; i++) {","  setTimeout(() => console.log(i), i * 1000);","}   // Output: 1, 2, 3"," ","// Using var (one shared i for all iterations)","for (var i = 1; i <= 3; i++) {","  setTimeout(() => console.log(i), i * 1000);","}   // Output: 4, 4, 4",""," ","// Fix for var → use IIFE to capture i","for (var i = 1; i <= 3; i++) {","  (function(i){","    setTimeout(() => console.log(i), i * 1000);","  })(i);","}   // Output: 1, 2, 3"],keyterms:["var = function scope (one binding for loop)","let = block scope (new binding per iteration)","IIFE = captures var value in its own closure"]},{id:32,question:"What are Event Listeners in JavaScript?",answer:["They run a handler when an event occurs (click, input, etc.).","Handlers are callbacks wired to elements or the window.","Multiple listeners can exist per event/element."],example:["document.getElementById('btn')","  .addEventListener('click', () => console.log('Clicked'));"],keyterms:["Listener = callback for an event","addEventListener(type, handler)"]},{id:33,question:"How do closures work with Event Listeners?",answer:["Listeners capture variables from their creation scope.","State can persist across multiple event triggers.","Be mindful: captured state keeps memory alive."],example:["function counter(){","  let count = 0;","  btn.addEventListener('click', () => console.log(++count));","}"," ","counter();"],keyterms:["Closure = function + lexical scope","Stateful listeners via closure"]},{id:34,question:"How does scope affect Event Listeners (var vs let)?",answer:["A function execution context is created only when a function is invoked (added to the call stack).Inside that context, JS maintains a Lexical Environment(variable env)","`var` is function-scoped → one variable shared across all iterations. Whereas`let` is block-scoped → each iteration gets its own copy of the variable.","With `var`, callbacks/event listeners see the final value after the loop. But, with `let`, callbacks/event listeners keep the correct value of each loop iteration.","Because the call stack frame is created only when a function executes, not on every loop iteration. With var, the loop runs inside the same function execution context, so it just reuses the same variable binding. Only let/const trigger creation of a fresh block environment record each iteration."],example:["// Using var → all callbacks share one i","for (var i=1; i<=3; i++){","  setTimeout(()=>console.log(i), 500);","}","// Output: 4,4,4"," ","// Using let → each iteration has its own i","for (let i=1; i<=3; i++){","  setTimeout(()=>console.log(i), 500);","}","// Output: 1,2,3"],keyterms:["var = function scope, shared binding","let = block scope, new binding per loop","closure = function remembers variable from outer scope"]},{id:35,question:"What are event listeners in JavaScript and how do onClick or onSubmit work?",answer:["Event listeners detect user actions like clicks, typing, or submitting forms.","They are used to make webpages interactive.","Common events: onClick, onSubmit, onChange, onFocus, onBlur."],example:["// HTML: <button id='btn'>Click Me</button>","document.getElementById('btn').addEventListener('click', () => {","  console.log('Button clicked');","});","","// onSubmit example","document.querySelector('form').addEventListener('submit', (e) => {","  e.preventDefault();","  console.log('Form submitted');","});"],keyterms:["Event listener = detects user action","onClick = triggers on button click","onSubmit = triggers when form submitted"]},{id:36,question:"What is the difference between setTimeout() and setInterval() in JavaScript?",answer:["Both are used to run functions after a time delay.","setTimeout() runs the function **once** after the delay.","setInterval() runs the function **repeatedly** at given intervals.","Both can be cleared using clearTimeout() and clearInterval()."],example:["setTimeout(() => console.log('Run once'), 1000);","const id = setInterval(() => console.log('Repeating...'), 2000);","// clearInterval(id) to stop"],keyterms:["setTimeout = runs function once after delay","setInterval = repeats function at fixed intervals"]},{id:37,question:"Why should you remove Event Listeners?",answer:["Listeners hold references via closures -> memory use.","Unused listeners can leak memory and slow apps.","Always remove when not needed."],example:["function handle(){ ","console.log('Click'); ","}"," ","btn.addEventListener('click', handle);"," ","// later move it","btn.removeEventListener('click', handle);"],keyterms:["removeEventListener = cleanup","Garbage collection needs no refs"]},{id:38,question:"What are Debouncing and Throttling with event listeners?",answer:["Debounce: delay execution until user stops triggering.","Throttle: limit executions to once per interval.","Both reduce unnecessary handler calls."],example:["// Debounce: wait for pause","function debounce(fn, delay){","  let t;","  return ()=>{ clearTimeout(t); t=setTimeout(fn, delay); };","}","button.onclick = debounce(()=>console.log('Debounced!'), 500);"," ","// Throttle: allow once per delay","function throttle(fn, delay){","  let last=0;","  return ()=>{","    if(Date.now()-last>delay){ fn(); last=Date.now(); }","  };","}","button.onclick = throttle(()=>console.log('Throttled!'), 1000);"],keyterms:["Debounce = wait then run","Throttle = run at fixed rate"]},{id:39,question:"What are synchronous and asynchronous code in JavaScript?",answer:["Synchronous code runs line-by-line, blocking further execution until the current task finishes.","Asynchronous code allows other tasks to run while waiting for an operation to complete, preventing blocking."],example:["// Synchronous","console.log('Start');","console.log('End');"," ","// Asynchronous","console.log('Start');","setTimeout(() => console.log('Async task'), 1000);","console.log('End');"],keyterms:["Synchronous = tasks run one after another, blocking","Asynchronous = tasks run without waiting, non-blocking"]},{id:40,question:"Why is JavaScript called single-threaded and synchronous?",answer:["JS runs on a single main thread executing one task at a time.","By default, code runs synchronously in order.","Global Execution context sits at the bottom of call stack, whenever a new function has to be executed theirs execution context is pushed to call stack, after completion its removed."],example:["console.log('A');","console.log('B');","console.log('C'); // strict order"],keyterms:["Single-threaded = one call stack","Synchronous = sequential execution"]},{id:41,question:"What does blocking the main thread mean in JavaScript?",answer:["A long synchronous task stops the event loop from processing other work.","UI freezes and DOM will not load if that piece of code comes at the beginning, thereby degrading user experience.","Use async patterns or Web Workers or execute that piece of code later when DOM loads properly to avoid blocking."],example:["console.log('Main thread blocking started');"," ","const start = Date.now();","while (Date.now() - start < 5000) {","  // blocks Main Thread for 5 sec","}"," ","console.log('Blocking ended');"],keyterms:["Blocking = main thread is busy","Non-blocking = yields to the loop","Web Workers = Background scripts that run in parallel with main thread"]},{id:42,question:"What is the Event Loop in JavaScript and how does it work?",answer:["The event loop is the mechanism that enables JavaScript (a single-threaded language) to handle asynchronous operations without blocking.","It constantly checks the call stack and queues to decide what to execute next, as soon as call stack becomes empty.","Microtask Queue: higher-priority queue for promises, MutationObserver, and queueMicrotask. Runs right after the current call stack is empty.","Callback/Task Queue: lower-priority queue for tasks like setTimeout, setInterval, DOM events, and network callbacks. Runs only after microtasks finish.","Concurrency Model: how JS manages multiple tasks without parallel threads, with the help of Event Loop which schedules task bw call stack and queues."],example:["console.log('Start');"," ","setTimeout(() => console.log('Task Queue: Timeout'), 0);"," ","Promise.resolve().then(() => console.log('Microtask Queue: Promise'));"," ","console.log('End');"," ","// Output order:","// Start → End → Microtask Queue: Promise → Task Queue: Timeout"],keyterms:["Event Loop = decides execution order of tasks","Call Stack = executes synchronous code","Microtask Queue = promises, MutationObserver (high priority)","Callback/Task Queue = setTimeout, events, I/O (lower priority)","Order = synchronous code → microtasks → tasks (callbacks)."]},{id:43,question:"What is the difference between Microtask Queue and Callback/Task Queue in JavaScript event loop?",answer:["Microtask Queue has higher priority — promises, MutationObserver, and queueMicrotask go here.","Callback/Task Queue is lower priority — setTimeout, setInterval, DOM events, and other async APIs go here.","After each synchronous code execution, the event loop empties the Microtask Queue before moving to the Callback/Task Queue.","This ensures promises resolve before timeouts and DOM callbacks."],example:["let fn = () => console.log('callback func');","setTimeout(fn, 1);"," ","fetch('https://jsonplaceholder.typicode.com/users').then((res) =>","  console.log('promise resolved')",");"],keyterms:["Microtask Queue = promises, MutationObserver, queueMicrotask","Callback/Task Queue = setTimeout, setInterval, DOM events","Priority = microtasks run before tasks"]},{id:44,question:"How do you handle asynchronous code using callbacks in JavaScript?",answer:["Callbacks pass a function as an argument to execute after an async task.","Simple for basic async, but can nest deeply."],example:["function callbackDemo() {","  setTimeout(() => console.log('Hello from Callback!'), 1000);","  console.log('Start');","}","callbackDemo(); "," ","// Output: 'Start' immediately, then 'Hello from Callback!' after 1s"],keyterms:["Callback = passed function","Async execution"]},{id:45,question:"How do you handle asynchronous code using Promises in JavaScript?",answer:["Promises is an object representing the eventual completion or failure of an async operation.","Code after a Promise runs immediately while the Promise is pending, showing async behavior.","Behaviour of Promise:","1. `Executes Only once.","2. `Immutable, so more trustworthy than callbacks.","3. `.then()` runs when the Promise resolves.","4. Only Pending, Fulfilled (resolved), Rejected are the states of a Promise."],example:["const promiseDemo = new Promise(res =>","  setTimeout(() => res('Hello from Promise!'), 1000)",");"," ","promiseDemo","  .then(msg => console.log(msg)) ","  .catch(err => console.error(err));"," ","console.log('Start');"," ","// Output: 'Start' immediately, then 'Hello from Promise!' after 1s"],keyterms:["Async execution = code runs while Promise is pending"]},{id:46,question:"How do you handle asynchronous code using async/await in JavaScript?",answer:["async/await pauses execution until a Promise resolves, making async code look synchronous and easier to read than chaining .then() with Promises.","Code after await (or after calling the async function) can run immediately, demonstrating async behavior.","Explanation of example:","1. `wait(ms)` returns a Promise that resolves after `ms` ms.","2. `await wait(1000)` pauses the async function for 1 second.","3. Errors can be handled with try/catch (optional if using .catch() outside)."],example:["function wait(ms) {","  return new Promise(res => setTimeout(() => res('async/await!'), ms));","}"," ","async function AsyncDemo() {","  const msg = await wait(1000);","  console.log(msg);  ","}"," ","AsyncDemo();","console.log('Start'); "," ","// Output: 'Start' immediately, then 'async/await!' after 1s"],keyterms:["Async/await = sync-like","Await = pause"]},{id:47,question:"Compare callbacks, promises, and async/await in JavaScript.",answer:["Callbacks: Oldest way, pass a function to handle async result. Simple but leads to nesting (callback hell).","Promises: Provide a cleaner async model by flattening the structure with .then() chaining, improving readability","Async/await: Built on promises, makes async code look synchronous, avoiding chaining entirely, gives sync-like code and better readability."],example:["Style      | Handling result     | Pros                 | Cons                   ","-----------|---------------------|----------------------|------------------------","Callback   | Inside callback fn  | Simple, built-in     | Callback hell, Inversion of Control","Promise    | .then()/.catch()    | Cleaner, chaining    | Verbose for many steps ","Async/Await| await inside async  | Readable, looks sync | Must be in async fn    "],keyterms:["Promise = .then/.catch chaining","Async/await = modern, cleaner syntax","Callback hell = happens when callbacks are nested deeply, making code hard to read and maintain."]},{id:48,question:"What is starvation of tasks in the Callback Queue in JavaScript?",answer:["Starvation happens when tasks in the Callback/Task Queue (like setTimeout, events) keep getting delayed.","This occurs if microtasks (promises, MutationObserver) continuously create new microtasks.","Since the event loop always empties the Microtask Queue before moving to the Callback Queue, endless microtasks can starve callback tasks.","This leads to timers, DOM events, or I/O callbacks being blocked indefinitely."],example:["console.log('Start');"," ","function endlessMicrotask() {","  Promise.resolve().then(() => {","    console.log('Microtask running');","    endlessMicrotask(); // schedules another microtask endlessly","  });","}"," ","endlessMicrotask();"," ","setTimeout(() => console.log('Task Queue: Timeout'), 0);"," ","// Output:","// Start → Microtask running → Microtask running → ... (infinite)","// Timeout never runs (starved)"],keyterms:["Starvation = when lower-priority tasks never get CPU time","Microtask Queue = higher priority, can block tasks if abused","Callback/Task Queue = lower priority, may starve if microtasks never finish"]},{id:49,question:"What are Promises in JavaScript and why are they used?",answer:["A Promise is an object that represents the eventual completion or failure of an asynchronous task.","It acts as a placeholder for a value that will be available in the future.","Promises help solve problems of callbacks like **callback hell** and **inversion of control**.","They provide a cleaner and more reliable way to handle async code."],example:["const promise = new Promise((resolve, reject) => {","  let success = true;","  success ? resolve('Done!') : reject('Error');","});","","promise.then(res => console.log(res))","       .catch(err => console.log(err));"],keyterms:["Promise = async placeholder object","Inversion of control = losing control to nested callbacks","Callback hell = nested callbacks making code hard to read"]},{id:50,question:"What are the different states of a Promise and how do they work?",answer:["A Promise has **3 states**: Pending, Fulfilled, and Rejected.","Pending → initial state before completion.","Fulfilled → operation completed successfully (resolved).","Rejected → operation failed with an error.","A promise is **immutable** once resolved or rejected."],example:["const promise = new Promise((resolve, reject) => {","  setTimeout(() => resolve('Success!'), 2000);","});","","promise.then(res => console.log(res)); // Fulfilled after 2s"],keyterms:["pending = waiting state","fulfilled = success","rejected = failed state","immutable = cannot change once settled"]},{id:51,question:"What is Promise chaining and why is it used?",answer:["Promise chaining helps run asynchronous operations **sequentially**.","Each `.then()` returns a new promise, allowing vertical readable code.","It avoids callback hell and keeps logic clean.","Always return a value or promise from `.then()` for the next chain."],example:["new Promise(resolve => resolve(10))","  .then(num => num * 2)","  .then(num => num + 5)","  .then(console.log); // 25"],keyterms:["chaining = linking .then() calls","return value = passed to next .then()","vertical structure = clean readable flow"]},{id:52,question:"How does error handling work in Promises?",answer:["`.catch()` is used to handle errors in promises.","It only catches errors from `.then()` placed before it.","Multiple `.catch()` blocks can handle different sections of a chain.","Always keep a final `.catch()` at the end to catch any unhandled error."],example:["new Promise((_, reject) => reject('Error!'))","  .then(() => console.log('Success'))","  .catch(err => console.log('Caught:', err))","  .then(() => console.log('Continues...'));"],keyterms:["catch = handles rejection","then = continues chain","error propagation = how rejections travel"]},{id:53,question:"What are async and await in JavaScript and how do they work internally?",answer:["'async' marks a function that always returns a Promise.","'await' pauses the async function until the Promise resolves.","Async/await provides a **synchronous look** to async code.","It is built on top of Promises and uses event loop for scheduling."],example:["const API_URL = 'https://api.github.com/users/ani';","","async function fetchUser() {","  const res = await fetch(API_URL);","  const data = await res.json();","  console.log(data);","}","","fetchUser();"],keyterms:["async = returns a promise","await = waits for promise result","event loop = handles async scheduling"]},{id:54,question:"When do async/await promises actually start running and how does timing work?",answer:["A Promise starts executing **as soon as it is created**, not when awaited.","Await only pauses function execution until the promise settles.","Timers or tasks inside a promise start immediately upon declaration.","If multiple promises are declared before awaits, they run **in parallel**."],example:["const p1 = new Promise(res => setTimeout(() => res('P1 done'), 5000));","const p2 = new Promise(res => setTimeout(() => res('P2 done'), 3000));","","async function demo() {","  const a = await p1; // waits 5s (timer already running)","  const b = await p2; // resolves instantly if already done","  console.log(a, b);","}","","demo(); // total ≈ 5s, not 8s"],keyterms:["promise start = at creation time","await = pauses async function only","parallel execution = both timers run together"]},{id:55,question:"What are Promise combinator methods (all, allSettled, race, any) in JavaScript and how do they differ?",answer:["Promise combinators handle multiple promises together.","Promise.all waits for all promises to fulfill or rejects if any fails.","Promise.allSettled waits for all to finish (fulfilled or rejected).","Promise.race settles as soon as the first promise settles (success or fail).","Promise.any fulfills when the first promise resolves, ignoring rejections. "],example:["const p1 = Promise.resolve('A');","const p2 = new Promise((res) => setTimeout(() => res('B'), 100));","const p3 = Promise.reject('C');","","Promise.all([p1, p2, p3])","  .then(res => console.log('All:', res))","  .catch(err => console.log('All Error:', err));","","Promise.allSettled([p1, p2, p3])","  .then(res => console.log('AllSettled:', res));","","Promise.race([p1, p2, p3])","  .then(res => console.log('Race:', res))","  .catch(err => console.log('Race Error:', err));","","Promise.any([p3, p2])","  .then(res => console.log('Any:', res))","  .catch(err => console.log('Any Error:', err));","","// Output:","// All Error: C","// AllSettled: [{status:'fulfilled', value:'A'}, {status:'fulfilled', value:'B'}, {status:'rejected', reason:'C'}]","// Race: A","// Any: B"],keyterms:["Promise.all = resolves if all succeed, rejects on any error","Promise.allSettled = Returns object with resolve/reject for all, safest among all","Promise.race = settles on first resolve/reject","Promise.any = looks for first success, but if all fails then returns array of aggregated errors."]},{id:56,question:"How does the 'this' keyword behave in JavaScript under different modes and scopes?",answer:["'this' refers to the object that is currently executing the function.","In global scope (non-strict), 'this' refers to the global object (window in browsers).","In strict mode, 'this' is undefined when used in a function (not bound automatically).","Inside an object method, 'this' refers to that object.","In arrow functions, 'this' is inherited from the outer lexical scope.","In event handlers, 'this' usually refers to the element that triggered the event.","In classes, 'this' refers to the instance of the class."],example:["// Global scope","console.log(this); // window (in browser), global (in Node.js)","","'use strict';","function show() { console.log(this); }","show(); // undefined in strict mode","","const obj = {","  name: 'Ani',","  normalFn: function() { console.log(this.name); },","  arrowFn: () => console.log(this.name)","};","","obj.normalFn(); // 'Ani' → 'this' refers to obj","obj.arrowFn();  // undefined → 'this' from outer scope (global)","","class User {","  constructor(name) { this.name = name; }","  greet() { console.log('Hi', this.name); }","}","new User('Anirudha').greet(); // 'Hi Anirudha'"],keyterms:["this (global, non-strict) = window/global object","this (strict mode) = undefined in normal functions","this (object method) = current object","this (arrow function) = inherited from outer scope","this (class method) = class instance"]},{id:57,question:"What does the 'this' keyword refer to in HTML event attributes, and how is it used with properties like .tagName?",answer:["In inline HTML event attributes (like onclick, onmouseover), 'this' refers to the element that triggered the event.","It allows direct access to the element’s properties and methods within the same tag.","For example, 'this.tagName' returns the name of the HTML tag in uppercase (e.g., BUTTON, DIV).","You can also use 'this' to modify styles or content dynamically (e.g., this.style.color = 'red')."],example:['<button onclick="alert(this.tagName)">Show Tag</button>',`<div onclick="this.style.background='yellow'">Click to Highlight</div>`],keyterms:["this = refers to the current HTML element handling the event","tagName = returns the element’s tag in uppercase","inline event = event defined directly inside the HTML tag"]},{id:58,question:"Explain the different behaviors of the 'this' keyword in JavaScript with examples.",answer:["'this' refers to the object that is executing the current function, and its value depends on where and how the function is called.","In **global scope**, 'this' refers to the global object (window/global).","In **non-strict mode**, if 'this' is undefined or null, it automatically defaults to the global object — known as **this substitution**.","In **strict mode**, 'this' remains undefined in normal functions.","In **object methods**, 'this' refers to the object before the dot (caller object).","In **DOM event handlers**, 'this' refers to the HTML element that triggered the event."],example:["// Global scope","console.log(this); // window (in browser)","","// Normal function - non-strict mode","function show() { console.log(this); }","show(); // window (this substitution)","","// Strict mode","'use strict';","function showStrict() { console.log(this); }","showStrict(); // undefined","","// Object method","const obj = { a: 10, print() { console.log(this.a); } };","obj.print(); // 10 (this → obj)","","// this in DOM","<button onclick='alert(this.tagName)'>Click Me</button>","// Alerts: BUTTON"],keyterms:["this = dynamic reference to execution context","this substitution = replacement of undefined/null with global object in non-strict mode","strict mode = keeps this as undefined in functions","method context = this refers to caller object","DOM this = HTML element that triggered the event"]},{id:59,question:"How can the 'this' value be explicitly controlled in JavaScript using call(), apply(), and bind()?",answer:["These methods are used to manually set or control the value of 'this' inside a function.","`call()` and `apply()` invoke the function immediately with a given 'this' value.","`bind()` returns a new function with the specified 'this' permanently bound.","They are used to share or borrow methods between different objects."],example:["const user1 = { name: 'Bruce' };","const user2 = { name: 'Clark' };","","function greet() { console.log('Hi', this.name); }","","greet.call(user1);  // Hi Bruce  → 'this' = user1","greet.apply(user2); // Hi Clark  → 'this' = user2","const bound = greet.bind(user1);","bound(); // Hi Bruce  → permanently bound to user1"],keyterms:["call() = invokes immediately, passes args individually","apply() = invokes immediately, passes args as array","bind() = returns new function with fixed this"]},{id:60,question:"How does the 'this' keyword behave inside arrow functions in JavaScript?",answer:["Arrow functions do **not** have their own 'this'.","They inherit 'this' from the **lexical (outer) scope** where they are defined.","Hence, their 'this' depends on where they are written, not on how they are called.","They are useful when you want to preserve the outer function’s 'this' value."],example:["// Arrow function in global scope","const show = () => console.log(this);","show(); // window (in browser)","","// Arrow inside a normal method","const obj = {","  name: 'Bruce',","  display: function() {","    const inner = () => console.log(this.name);","    inner(); // inherits this from display()","  }","};","obj.display(); // 'Bruce'"],keyterms:["arrow function = inherits this from outer scope","lexical this = static this from definition context","normal function = creates its own dynamic this"]},{id:61,question:"How does the value of 'this' change in different execution contexts such as global, object methods, and class constructors?",answer:["In the **global context**, 'this' refers to the global object (window in browser, global in Node).","Inside a **function** (non-strict mode), 'this' defaults to the global object; in strict mode, it stays undefined.","Within an **object method**, 'this' refers to the object that called the method.","In a **class constructor**, 'this' represents the newly created instance of the class.","When **methods are detached** or passed as callbacks, 'this' may become undefined or refer to the global object."],example:["// Global context","console.log(this === window); // true (in browser)","","// Object method","const user = { name: 'Ani', show() { console.log(this.name); } };","user.show(); // 'Ani'","","// Class constructor","class Person { constructor(name) { this.name = name; } }","const p = new Person('Riya');","console.log(p.name); // 'Riya'"],keyterms:["execution context = scope where 'this' is evaluated","global context = top-level scope (window/global)","object method = 'this' refers to the object itself","class constructor = 'this' refers to new instance"]},{id:62,question:"What are call, apply, and bind methods in JavaScript and how do they differ?",answer:["All three are used to **manually set 'this'** inside a function.","**call()** invokes the function immediately with given arguments listed individually.","**apply()** is similar but takes arguments as an **array**.","**bind()** returns a **new function** with 'this' permanently bound — it doesn't execute immediately."],example:["const person = { name: 'Ani' };","","function greet(place, country) {","  console.log(`Hi, I'm ${this.name} from ${place}, ${country}`);","}","","greet.call(person, 'Udupi', 'India');      // call → executes immediately","greet.apply(person, ['Udupi', 'India']);   // apply → same but args as array","const boundFn = greet.bind(person, 'Udupi', 'India');","boundFn();                                 // bind → executes later"],keyterms:["call() = execute function immediately with given this and args","apply() = same as call but takes args as array","bind() = returns new function with this permanently bound"]},{id:63,question:"How can we create a simple custom version of the 'bind()' method in JavaScript?",answer:["'bind()' lets us fix 'this' for a function.","We can recreate it easily using a custom 'myBind' method.","It returns a new function that runs the original one with a fixed 'this'."],example:["Function.prototype.myBind = function(obj) {","  const fn = this;","  return function() {","    fn.call(obj);","  };","};","","const person = {","  name: 'Ani'","};","","function sayHi() {","  console.log('Hi', this.name, 'from Udupi');","}","","const hi = sayHi.myBind(person);","hi(); // Hi Ani from Udupi"],keyterms:["bind() = creates a new function with fixed 'this'","call() = invokes function with given 'this' value","custom bind = manual way to lock 'this'"]},{id:64,question:"What is the map() method in JavaScript?",answer:["map() creates a new array by applying a transformation function to each element.","It does not modify the original array.","Commonly used for data transformation, like extracting fields or converting values."],example:["const numbers = [1, 2, 3, 4];"," ","const squared = numbers.map(n => n * n);"," ","console.log(squared); // [1, 4, 9, 16]"],keyterms:["map = transform all elements","Returns new array = same length as input","Pure function = no mutation of original array"]},{id:65,question:"What is the filter() method in JavaScript?",answer:["filter() creates a new array with only elements that pass the provided condition.","Does not change the original array.","Useful for extracting subsets of data."],example:["const numbers = [10, 15, 20, 25, 30];"," ","const evens = numbers.filter(n => n % 2 === 0);"," ","console.log(evens); // [10, 20, 30]"],keyterms:["filter = pick elements matching condition","Returns new array = length ≤ original","Condition function = returns true/false"]},{id:66,question:"What is the reduce() method in JavaScript?",answer:["reduce() applies a reducer function to all elements of an array, returning a single accumulated result.","Takes two arguments: a callback (with accumulator and current value) and an initial value.","Common use cases: sum, average, max/min, object grouping."],example:["const prices = [5, 10, 15];","const total = prices.reduce((acc, curr) => acc + curr, 0);","console.log(total); // 30"," ","const maxVal = prices.reduce((max, curr) => curr > max ? curr : max, 0);","console.log(maxVal); // 15"],keyterms:["reduce = compress array into single value","Accumulator = stores running result","Initial value = starting point for accumulator"]},{id:67,question:"What is a Polyfill for map, filter, and reduce, and how to implement it?",answer:["A polyfill is custom code that adds support for a feature if it is not available in a browser.","Polyfills ensure older environments can still use modern array methods.","For map, filter, and reduce, polyfills mimic their original behavior using for-loops."],example:["// Polyfill for map"," ","if (!Array.prototype.myMap) {","  Array.prototype.myMap = function(cb) {","    const result = [];","    for (let i = 0; i < this.length; i++) {","      result.push(cb(this[i], i, this));","    }","    return result;","  };","}"," ","const nums = [1, 2, 3];","const doubled = nums.myMap(n => n * 2);","console.log(doubled); // [2, 4, 6]"],keyterms:["Polyfill = custom implementation of a feature","Needed for backward compatibility","Implemented by extending prototypes (like Array.prototype)"]},{id:68,question:"What is Memoization and how does it use closures?",answer:["Caching function results to avoid recomputation.","Closure keeps a private cache map/object.","Great for expensive pure functions."],example:["function memoize(fn) {","  const cache = {};","  return n => cache[n] ?? (cache[n] = fn(n));","}"," ","const slowSquare = n => {","  for (let i = 0; i < 1e6; i++) {}","  return n * n;","};"," ","const fastSquare = memoize(slowSquare);"],keyterms:["Memoization = cache results","Closure holds cache"]},{id:69,question:"Which is more common in JavaScript: OOP or Functional Programming, and why?",answer:["Both paradigms exist in JavaScript, but functional programming is more common in day-to-day code.","JavaScript treats functions as first-class citizens, making it natural to use map, filter, reduce, callbacks, and promises.","OOP (with classes/objects) is still used, especially for structuring large applications and frameworks (like React classes before hooks).","Modern JS often uses a mix: functional style for data handling, OOP for app architecture."],example:["// Functional style","[1, 2, 3].map(x => x * 2); // [2, 4, 6]"," ","// OOP style","class Counter {","  constructor() { this.value = 0; }","  inc() { this.value++; }","}","const c = new Counter();","c.inc(); console.log(c.value); // 1"],keyterms:["Functional programming = uses functions as primary building blocks","OOP = organizes code into objects/classes","JavaScript = multi-paradigm (supports both)"]},{id:70,question:"What is Object-Oriented Programming (OOP) in JavaScript and what are its main principles?",answer:["OOP in JavaScript is a programming paradigm where data (objects) and behavior (methods) are bundled together.","JS supports OOP using prototypes and classes.","The 4 key principles are: Encapsulation, Abstraction, Inheritance, and Polymorphism."],keyterms:["OOP = programming paradigm combining data and behavior in objects","Encapsulation = binding data with methods and keeping them private","Abstraction = hiding implementation details and exposing only necessary interfaces","Inheritance = reusing properties/methods from parent objects","Polymorphism = ability of a method to take multiple forms depending on context"]},{id:71,question:"How is Encapsulation achieved in JavaScript?",answer:["Encapsulation means keeping data (variables) safe from direct access and exposing only necessary methods.","Achieved using closures or private fields (#) inside classes."],example:["class BankAccount {","  #balance = 0;","  deposit(amount) { this.#balance += amount; }","  getBalance() { return this.#balance; }","}"," ","const acc = new BankAccount();","acc.deposit(500);","console.log(acc.getBalance()); // 500"],keyterms:["Private field = variable not directly accessible","Encapsulation = data hiding with controlled access"]},{id:72,question:"What is Abstraction in JavaScript?",answer:["Abstraction means exposing only necessary features while hiding details.","In JS, achieved via abstract base classes or by designing APIs that hide implementation."],example:["class Car {","  start() { console.log('Car started'); }","  stop() { console.log('Car stopped'); }","  // details like fuel injection are hidden","}"," ","const c = new Car();","c.start(); // Car started"],keyterms:["Abstraction = hide details, show essentials","API design = practical abstraction"]},{id:73,question:"What is Inheritance in JavaScript?",answer:["Inheritance allows one class to acquire properties and methods of another class.","In JavaScript, achieved using 'extends' keyword with classes or Object.create with prototypes."],example:["class Animal {","  speak() { console.log('Animal sound'); }","}"," ","class Dog extends Animal {","  speak() { console.log('Woof!'); }","}"," ","new Dog().speak(); // 'Woof!'"],keyterms:["extends = keyword for class inheritance","Prototype chain = mechanism behind inheritance"]},{id:74,question:"What is Polymorphism in JavaScript?",answer:["Polymorphism means the same method name can behave differently based on the object.","In JavaScript, achieved by method overriding or using dynamic typing."],example:["class Shape { area() { return 0; } }"," ","class Circle extends Shape {","  constructor(r) { super(); this.r = r; }","  area() { return Math.PI * this.r * this.r; }","}"," ","class Square extends Shape {","  constructor(s) { super(); this.s = s; }","  area() { return this.s * this.s; }","}"," ","console.log(new Circle(3).area()); // 28.27","console.log(new Square(4).area()); // 16"],keyterms:["Polymorphism = multiple forms of same method","Overriding = redefining parent method in child"]},{id:75,question:"How do functions relate to constructors and prototypes in JavaScript?",answer:["Functions can be used with `new` as constructors to create object instances.","Methods can be placed on `FunctionName.prototype` to share across all instances, saving memory.","Each instance can still have its own properties, but methods on prototype are shared."],example:["function Person(name) {","  this.name = name;","}"," ","Person.prototype.sayHi = function() {","  console.log('Hi ' + this.name);","};"," ","const ani = new Person('Ani');","ani.sayHi(); // Hi Ani"],keyterms:["Constructor = function used with new to create objects","Prototype = object shared among all instances","Prototype chain = lookup path JS uses for inherited properties/methods"]},{id:76,question:"What is the difference between prototypal and classical inheritance in JavaScript?",answer:["Classical → objects inherit from classes (like Java, C++).","Prototypal → objects inherit directly from other objects.","JS internally uses prototypal inheritance, though `class` syntax is syntactic sugar."],example:["// Classical style","class Animal { speak() { console.log('sound'); } }","class Dog extends Animal { speak() { console.log('woof'); } }","new Dog().speak(); // woof"," ","// Prototypal style","const animal = { speak() { console.log('sound'); } };","const dog = Object.create(animal);","dog.speak = () => console.log('woof');","dog.speak(); // woof"],keyterms:["Prototype = parent object from which others inherit","Prototype chain = path JS uses to look up inherited properties","Classical inheritance = class-based, blueprint-like inheritance","Prototypal inheritance = object-to-object inheritance"]},{id:77,question:"What is Prototyping in JavaScript?",answer:["Prototyping is the process of adding new methods or properties to built-in objects through their prototype.","When added to the prototype, the method becomes available to all instances of that object type.","It allows extending JavaScript’s core objects, though modifying built-in prototypes in production is generally discouraged."],example:["// Add a custom method to String prototype"," ","String.prototype.reverse = function () {","  return this.split('').reverse().join('');","};"," ","console.log('hello'.reverse()); // 'olleh'"],keyterms:["Prototype = object that other objects inherit from","Prototyping = extending core objects with new methods","Instance = any object created from a constructor (e.g., string, array)"]},{id:78,question:"What are different types of JavaScript errors like SyntaxError, ReferenceError, TypeError, RangeError, and AggregateError?",answer:["JavaScript has built-in error types to identify specific runtime issues.","SyntaxError → occurs when code syntax is invalid.","ReferenceError → occurs when accessing an undefined variable or reference.","TypeError → occurs when an operation is done on the wrong data type.","RangeError → occurs when a value is not in the expected range.","AggregateError → groups multiple errors (mainly used with Promise.any)."],example:["// SyntaxError: Missing parenthesis","// eval('let x = ;');","","// ReferenceError","console.log(a); // 'a' is not defined","","// TypeError","let num = 10;","num.toUpperCase(); // invalid method on number","","// RangeError","let arr = new Array(-5); // invalid array length","","// AggregateError (used with Promise.any)","Promise.any([","  Promise.reject('Err1'),","  Promise.reject('Err2')","]).catch(e => console.log(e.errors)); // ['Err1', 'Err2']"],keyterms:["SyntaxError = invalid code structure or missing symbols","ReferenceError = using variable before declaration or non-existent","TypeError = wrong data type operation","RangeError = number/value out of valid range","AggregateError = group of multiple errors in one object"]},{id:79,question:"What are object methods in JavaScript and how do they differ from normal functions?",answer:["Object methods are functions stored as properties of objects.","ES6 introduced shorthand method syntax for cleaner definitions.","Arrow functions as methods do not have their own 'this', while normal functions and shorthand methods do."],example:["const user = {","  name: 'Ani',","  sayHi() { console.log('Hi ' + this.name); },       // shorthand method","  arrowHi: () => console.log('Hi ' + this.name),     // arrow method (no own this)","  normalHi: function() { console.log('Hello ' + this.name); } // normal function","};","","user.sayHi();    // 'Hi Ani'","user.arrowHi();  // 'Hi undefined' in strict mode","user.normalHi(); // 'Hello Ani'"],keyterms:["Object method = function stored in object property","Method shorthand = ES6 concise syntax","Arrow method = inherits this from outer scope","Normal function method = explicit function keyword"]},{id:80,question:"What are JavaScript generators?",answer:["Generators are special functions that can pause (`yield`) and later resume execution.","Defined with `function*` syntax and use `yield` to return values step by step.","Calling a generator does not run it immediately—it returns an iterator object.","Execution continues each time `.next()` is called, maintaining internal state."],example:["function* gen(){","  yield 1;","  yield 2;","  yield 3;","}","const it = gen();","console.log(it.next().value); // 1","console.log(it.next().value); // 2","console.log(it.next().value); // 3"],keyterms:["generator = resumable function","yield = pause/return value","iterator = object returned by generator"]},{id:81,question:"What are Symbols in JavaScript?",answer:["Symbols are **unique and immutable primitive values**.","They are often used as **object keys** to avoid naming conflicts.","Even Symbols with the same description are different.","Symbols can be used to add **safe, hidden properties** to objects."],example:["// Create a unique Symbol (here id is a unique Symbol, not a string)","const id = Symbol('id');","const obj = {};","obj[id] = 10; // property key is the Symbol, not a string"," ","// Every Symbol is unique","const a = Symbol('id');","const b = Symbol('id');","console.log(a === b); // false"],keyterms:["Symbol = unique key","hidden properties = keys not easily collided with others"]},{id:82,question:"What is smart garbage collection in modern JavaScript engines?",answer:["Modern JS engines have garbage collectors that automatically free memory used by variables no longer accessible.","Smart garbage collection can detect variables inside closures that are no longer used and release them, even if the closure itself exists.","This prevents memory leaks in long-running applications where closures retain references unnecessarily.","Smart collectors optimize performance by reducing memory usage without waiting for the entire closure to go out of scope."],example:["function createCounter() {","  let count = 0; // local variable inside closure","  return function() {","    console.log('Incremented'); // 'count' is never used","  };","}"," ","const counter = createCounter();","counter();","// Modern garbage collectors may free 'count' memory since it's not used"],keyterms:["Garbage Collector = automatically frees memory for unreachable objects, Uses mark-and-sweep;","Closure = hinder by retaining references.","Smart GC = detects unused variables inside closures and cleans them early","Memory Leak = retained memory that is no longer needed"]},{id:83,question:"How do Closures Affect Garbage Collection?",answer:["Closures allocate a lot of memory which cannot be deleted so this acts as a disadvantage.","Retain outer vars, preventing GC until closure discarded."],example:["function outer() {","  let data = new Array(1e6);","  return () => data;","}"," ","const closure = outer(); // data retained"],keyterms:["Closure = memory hold","Disadvantage = leak risk"]},{id:84,question:"Why Remove Event Listeners for Garbage Collection?",answer:["Unused variables are automatically deleted... Closures allocate a lot of memory which cannot be deleted.","Some browsers now have smart garbage collectors that automatically deletes variables that are not used outside closures.","Removing listeners releases closure refs for GC."],example:["element.removeEventListener('click', handler); // Frees memory"],keyterms:["Smart GC = auto delete","Listener remove = GC aid"]},{id:85,question:"What is the Mark-and-Sweep algorithm in garbage collection?",answer:["It is a tracing garbage collection technique used in JS engines.","It has two phases: Mark and Sweep.","Mark phase: all reachable objects are marked as 1 using DFS traversal.","Sweep phase: objects still marked as 0 are deleted from heap memory.","After sweeping, all reachable objects are reset to 0 for the next cycle."],keyterms:["Mark phase = identifies reachable objects via DFS","Sweep phase = removes unreachable objects","Heap memory = memory area where objects are stored","DFS (Depth-First Search) = traversal method used to mark reachable objects","Tracing GC = garbage collector that works by tracing object references"]},{id:86,question:"Is JavaScript compiled or interpreted? Explain Google Chrome's V8 execution pipeline.",answer:["JavaScript is a high-level language that is both interpreted and compiled (Just-In-Time compilation).","V8 engine first parses JS code into an Abstract Syntax Tree (AST) to understand the program structure.","Ignition, the interpreter, converts the AST into bytecode and starts execution quickly (baseline performance).","Turbofan, the optimizing compiler, monitors running code and compiles hot functions into highly optimized machine code for faster execution.","This pipeline allows JavaScript to start running immediately while still achieving high performance for frequently used code."],example:["// JS code","let sum = (a, b) => a + b;","console.log(sum(5, 10)); // 15"," ","// V8 execution:","// 1. Parser → creates AST","// 2. Ignition Interpreter → generates bytecode and executes","// 3. Turbofan Compiler → optimizes hot code into machine code"],keyterms:["Compiled vs Interpreted = JS uses JIT compilation (both)","Parser = converts code into Abstract Syntax Tree (AST)","AST = tree representation of code structure","Ignition = baseline interpreter producing bytecode","Turbofan = optimizing compiler for hot code","Bytecode = low-level instructions executed by V8"]},{id:87,question:"What are some key memory and performance optimizations in JavaScript engines?",answer:["Mark-and-Sweep: Garbage collector marks reachable objects and deletes unmarked ones to free memory.","Inlining: Functions are replaced by their body in hot code to reduce call overhead.","Copy Elision: Avoids unnecessary copying of objects/values when returning or passing them.","Inline Caching: Caches property access patterns for faster repeated object property lookups."],example:["// Mark-and-Sweep","let obj = {a: 1};","obj = null; // unreachable → collected by GC"," ","// Inlining","function add(a,b){ return a+b; }","// JS engine may replace add(x,y) with x+y"," ","// Copy Elision","function createPoint(){ return {x:0, y:0}; }","// engine avoids extra copying of object"," ","// Inline Caching","let obj = {name:'Ani'};","console.log(obj.name);","// engine caches property lookup for speed"],keyterms:["Mark-and-Sweep = GC deletes unreachable memory","Inlining = replaces function calls with body","Copy Elision = avoids unnecessary copies","Inline Caching = caches property access paths for speed"]},{id:88,question:"What is the difference between Web Worker and Service Worker in JavaScript?",answer:["Web Worker runs background threads for heavy computations (keeps UI responsive).","Service Worker acts as a proxy between browser & network (handles caching, offline support, push notifications).","Web Worker has no direct access to DOM, Service Worker also cannot access DOM but can intercept network requests.","Web Worker ends when the page is closed, Service Worker persists beyond page (event-driven, works even when page is closed)."],example:["// Web Worker Example","const worker = new Worker('worker.js');","worker.postMessage('start');","worker.onmessage = e => console.log(e.data);"," ","// Service Worker Example","navigator.serviceWorker.register('/sw.js');","self.addEventListener('fetch', event => {","  event.respondWith(fetch(event.request));","});"],keyterms:["Web Worker = Background thread for computation","Service Worker = Proxy layer for caching, offline, push","Thread = Separate execution flow","Event-driven = Reacts to events like fetch, push"]},{id:89,question:"What is the Singleton Pattern in JavaScript and how can it be implemented?",answer:["Singleton ensures that only one instance of an object is created throughout the application.","It provides a global access point to that instance.","Used for managing shared resources like configuration, logging, or database connections."],example:["// Simple Singleton Example","class Singleton {","  constructor() {","    if (Singleton.instance) return Singleton.instance; // Return existing instance","    this.value = Math.random();","    Singleton.instance = this;","  }","}","","const obj1 = new Singleton();","const obj2 = new Singleton();","console.log(obj1 === obj2); // true (same instance)","console.log(obj1.value, obj2.value); // same value"],keyterms:["Singleton = Design pattern that restricts class instantiation to one object","Instance = The single created object reused throughout the app","Global Access = The instance is accessible from anywhere"]}];export{e as default};
