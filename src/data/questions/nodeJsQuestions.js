const nodeJsQuestions = [
  {
    id: 1,
    question:
      "What is the difference between dependencies and devDependencies in Node.js?",
    answer: [
      "dependencies are packages required for the application to run in production.",
      "devDependencies are packages only needed during development (e.g., testing, building, linting).",
    ],
    example: [
      "// Installing a normal dependency",
      "npm install express",
      " ",
      "// Installing a dev dependency",
      "npm install nodemon --save-dev",
    ],
    keyterms: [
      "dependencies = required in production (e.g., express, mongoose)",
      "devDependencies = used only in development (e.g., nodemon, jest)",
    ],
  },
  {
    id: 2,
    question: "What is JWT and what are its types?",
    answer: [
      "JWT (JSON Web Token) is a compact, URL-safe way to transmit information securely between parties as a JSON object.",
      "It has three parts: Header, Payload, and Signature. Types are usually based on usage â€” Access Tokens (short-lived) and Refresh Tokens (long-lived).",
      "It is commonly used for authentication: server issues a token after login, and client sends it with each request for verification.",
    ],
    example: [
      "// Creating JWT",
      "const token = jwt.sign({ userId: 1 }, 'secret', { expiresIn: '1h' });",
      " ",
      "// Verifying JWT",
      "const decoded = jwt.verify(token, 'secret');",
    ],
    keyterms: [
      "JWT = JSON Web Token (Header + Payload + Signature)",
      "Access Token = short-lived token for API access",
      "Refresh Token = long-lived token to get new access tokens",
    ],
  },
  {
    id: 3,
    question: "What is the Event Loop in Node.js?",
    answer: [
      "The Event Loop is what allows Node.js to perform non-blocking I/O operations despite JavaScript being single-threaded.",
      "It continuously checks the call stack and processes callbacks from the event queue when the stack is empty.",
    ],
    example: [
      "console.log('Start');",
      "setTimeout(() => console.log('Timeout'), 0);",
      "setImmediate(() => console.log('Immediate'));",
      "process.nextTick(() => console.log('Next Tick'));",
      "console.log('End');",
      " ",
      "// Output: Start, End, Next Tick, Immediate, Timeout",
    ],
    keyterms: [
      "Event Loop = manages asynchronous operations",
      "Call Stack = tracks function execution",
      "Event Queue = holds callbacks to be executed",
    ],
  },
  {
    id: 4,
    question: "What are Streams in Node.js and why are they useful?",
    answer: [
      "Streams are objects used to read/write data continuously in chunks instead of loading everything into memory.",
      "Useful for handling large files, network communications, and real-time data processing efficiently.",
      "Types: Readable, Writable, Duplex, and Transform streams.",
    ],
    example: [
      "const fs = require('fs');",
      "const readStream = fs.createReadStream('input.txt');",
      "const writeStream = fs.createWriteStream('output.txt');",
      "readStream.pipe(writeStream);",
    ],
    keyterms: [
      "Stream = data in chunks for efficient processing",
      "Pipe = connects readable to writable stream",
      "Backpressure = handling flow when writable is slower",
    ],
  },
  {
    id: 5,
    question:
      "What is the difference between process.nextTick() and setImmediate()?",
    answer: [
      "process.nextTick() schedules a callback to execute **before** the next event loop tick.",
      "setImmediate() schedules a callback to execute at the end of the current event loop cycle.",
      "Use nextTick for critical operations that should run before I/O events, setImmediate for deferred execution.",
    ],
    example: [
      "console.log('Start');",
      "process.nextTick(() => console.log('Next Tick'));",
      "setImmediate(() => console.log('Immediate'));",
      "console.log('End');",
      " ",
      "// Output: Start, End, Next Tick, Immediate",
    ],
    keyterms: [
      "nextTick = runs before I/O events",
      "setImmediate = runs after I/O callbacks",
      "Event Loop phases = timers, I/O callbacks, idle, poll, check, close",
    ],
  },
  {
    id: 6,
    question: "What are clusters in Node.js and why are they used?",
    answer: [
      "Cluster module allows Node.js to take advantage of multi-core CPUs by creating child processes (workers).",
      "Workers share the same server port but run independently, improving scalability and fault tolerance.",
      "Useful for CPU-intensive tasks and handling many concurrent connections.",
    ],
    example: [
      "const cluster = require('cluster');",
      "const http = require('http');",
      "const numCPUs = require('os').cpus().length;",
      " ",
      "if (cluster.isMaster) {",
      "  for (let i = 0; i < numCPUs; i++) { cluster.fork(); }",
      "} else {",
      "  http.createServer((req, res) => res.end('Hello')).listen(3000);",
      "}",
    ],
    keyterms: [
      "Cluster = fork multiple processes for concurrency",
      "Worker = child process",
      "Master = main process controlling workers",
    ],
  },
  {
    id: 7,
    question:
      "How does Node.js handle asynchronous I/O with callbacks, promises, and async/await?",
    answer: [
      "Node.js uses non-blocking asynchronous I/O to handle operations without stopping the main thread.",
      "Callbacks are functions passed as arguments to handle results after completion.",
      "Promises provide a more readable chainable way to handle async operations.",
      "async/await allows writing asynchronous code in a synchronous-like manner, improving readability.",
    ],
    example: [
      "// Callback",
      "fs.readFile('file.txt', (err, data) => {",
      "  if (!err) console.log(data);",
      "});",
      " ",
      "// Promise",
      "fs.promises.readFile('file.txt')",
      "  .then(data => console.log(data));",
      " ",
      "// Async/Await",
      "async function read() {",
      "  const data = await fs.promises.readFile('file.txt');",
      "  console.log(data);",
      "}",
    ],
    keyterms: [
      "Non-blocking I/O = main thread is not blocked",
      "Callback = function called after async task",
      "Promise = async result container",
      "Async/Await = syntactic sugar for promises",
    ],
  },
  {
    id: 8,
    question: "What are middleware functions in Express.js?",
    answer: [
      "Middleware are functions executed during the request-response cycle in Express.",
      "They can modify request/response objects, perform logging, authentication, or terminate the request.",
      "Order matters: they execute sequentially in the order defined.",
    ],
    example: [
      "const express = require('express');",
      "const app = express();",
      " ",
      "// Logging middleware",
      "app.use((req, res, next) => { console.log(req.url); next(); });",
      " ",
      "app.get('/', (req, res) => res.send('Hello'));",
    ],
    keyterms: [
      "Middleware = function between request and response",
      "next() = pass control to next middleware",
      "Request lifecycle = order of middleware execution",
    ],
  },
  {
    id: 9,
    question: "What are common security best practices in Node.js?",
    answer: [
      "Validate and sanitize all user input to prevent injections.",
      "Use HTTPS and secure cookies for client-server communication.",
      "Avoid storing secrets in source code; use environment variables.",
      "Keep dependencies updated to avoid vulnerabilities.",
    ],
    example: [
      "// Using dotenv for environment variables",
      "require('dotenv').config();",
      "const dbPassword = process.env.DB_PASSWORD;",
    ],
    keyterms: [
      "Input validation = prevent malicious input",
      "HTTPS = secure transport",
      "dotenv = manage secrets",
      "Vulnerability = security weakness",
    ],
  },
  {
    id: 10,
    question: "What are Event Emitters in Node.js and how are they used?",
    answer: [
      "EventEmitter is a core class in Node.js that allows objects to emit named events and register listeners for them.",
      "It enables decoupled asynchronous communication within the application.",
      "Commonly used for signaling, logging, custom events, and handling async tasks without callbacks.",
    ],
    example: [
      "const EventEmitter = require('events');",
      "const emitter = new EventEmitter();",
      " ",
      "// Register listener",
      "emitter.on('greet', (name) => { console.log(`Hello ${name}`); });",
      " ",
      "// Emit event",
      "emitter.emit('greet', 'Ani'); // Output: Hello Ani",
    ],
    keyterms: [
      "EventEmitter = emits and listens to events",
      "on() = registers an event listener",
      "emit() = triggers the event",
      "Asynchronous signaling = notify listeners without blocking",
    ],
  },
];
export default nodeJsQuestions;
